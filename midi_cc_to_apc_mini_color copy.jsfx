desc:APC Mini Pad RGB Toggle - Banked + Color Picker [SysEx-only OUT] + Simple Logs (IN/Shift/Toggle/Color/SysEx)

// ====================================================================
// PURPOSE
// - Control APC Mini mk2 pad RGB via SysEx
// - Only SysEx output (NO MIDI thru)
// - Toggle per pad within active bank (16 notes per bank, 4 banks total)
// - Simple logs in @gfx (style similar to Note On Toggler example)
// ====================================================================

// -------------------------
// Sliders
// -------------------------
slider1:0<0,3,1{Bank 1,Bank 2,Bank 3,Bank 4}>Active Pad Bank
slider2:0<0,63,1>Last Triggered Pad (readonly)
slider3:0<0,127,1>Pad Color Index
slider4:0<0,15,1>Input MIDI Channel (0=Ch1 ... 15=Ch16)
slider5:0<-127,127,1>Note Shift (Semitones)

// -------------------------
// @init
// -------------------------
@init
gfx_a = 1;
gfx_clear = 0;
sysex_len = 16;

// Toggle states for 16 pads (per active bank)
pad0=pad1=pad2=pad3=pad4=pad5=pad6=pad7=pad8=pad9=pad10=pad11=pad12=pad13=pad14=pad15=0;

// APC color palette (0xRRGGBB), 0..127
color[0]=0x000000;  color[1]=0x1E1E1E;  color[2]=0x7F7F7F;  color[3]=0xFFFFFF;  color[4]=0xFF4C4C;
color[5]=0xFF0000;  color[6]=0x590000;  color[7]=0x190000;  color[8]=0xFFBD6C;  color[9]=0xFF5400;
color[10]=0x591D00; color[11]=0x271B00; color[12]=0xFFFF4C; color[13]=0xFFFF00; color[14]=0x595900;
color[15]=0x191900; color[16]=0x88FF4C; color[17]=0x54FF00; color[18]=0x1D5900; color[19]=0x142B00;
color[20]=0x4CFF4C; color[21]=0x00FF00; color[22]=0x005900; color[23]=0x001900; color[24]=0x4CFF5E;
color[25]=0x00FF19; color[26]=0x00590D; color[27]=0x001902; color[28]=0x4CFF88; color[29]=0x00FF55;
color[30]=0x00591D; color[31]=0x001F12; color[32]=0x4CFFB7; color[33]=0x00FF99; color[34]=0x005935;
color[35]=0x001912; color[36]=0x4CC3FF; color[37]=0x00A9FF; color[38]=0x004152; color[39]=0x001019;
color[40]=0x4C88FF; color[41]=0x0055FF; color[42]=0x001D59; color[43]=0x000819; color[44]=0x4C4CFF;
color[45]=0x0000FF; color[46]=0x000059; color[47]=0x000019; color[48]=0x874CFF; color[49]=0x5400FF;
color[50]=0x190064; color[51]=0x0F0030; color[52]=0xFF4CFF; color[53]=0xFF00FF; color[54]=0x590059;
color[55]=0x190019; color[56]=0xFF4C87; color[57]=0xFF0054; color[58]=0x59001D; color[59]=0x220013;
color[60]=0xFF1500; color[61]=0x993500; color[62]=0x795100; color[63]=0x436400; color[64]=0x033900;
color[65]=0x005735; color[66]=0x00547F; color[67]=0x0000FF; color[68]=0x00454F; color[69]=0x2500CC;
color[70]=0x7F7F7F; color[71]=0x202020; color[72]=0xFF0000; color[73]=0xBDFF2D; color[74]=0xAFED06;
color[75]=0x64FF09; color[76]=0x108B00; color[77]=0x00FF87; color[78]=0x00A9FF; color[79]=0x002AFF;
color[80]=0x3F00FF; color[81]=0x7A00FF; color[82]=0xB21A7D; color[83]=0x402100; color[84]=0xFF4A00;
color[85]=0x88E106; color[86]=0x72FF15; color[87]=0x00FF00; color[88]=0x3BFF26; color[89]=0x59FF71;
color[90]=0x38FFCC; color[91]=0x5B8AFF; color[92]=0x3151C6; color[93]=0x877FE9; color[94]=0xD31DFF;
color[95]=0xFF005D; color[96]=0xFF7F00; color[97]=0xB9B000; color[98]=0x835D07; color[99]=0x392B00;
color[100]=0x144C10; color[101]=0x1AD000; color[102]=0x0D5038; color[103]=0x15152A; color[104]=0x16205A;
color[105]=0x693C1C; color[106]=0xA8000A; color[107]=0xDE513D; color[108]=0xD86A1C; color[109]=0xFFE126;
color[110]=0x9EE12F; color[111]=0x67B50F; color[112]=0x1E1E30; color[113]=0xDCFF6B; color[114]=0x80FFBD;
color[115]=0x9A99FF; color[116]=0x8E66FF; color[117]=0x404040; color[118]=0x757575; color[119]=0xE0FFFF;
color[120]=0xA00000; color[121]=0x350000; color[122]=0x1AD000; color[123]=0x074200; color[124]=0xB9B000;
color[125]=0x3F3100; color[126]=0xB35F00; color[127]=0x4B1502;

// -------------------------
// Simple log state (like your reference script)
// -------------------------
// IN
last_in_status=-1; last_in_ch=-1; last_in_d1=-1; last_in_d2=-1;
// Note shift
last_shift_orig=-1; last_shift_amt=0; last_shift_new=-1;
// Toggle
last_pad_index=-1; last_toggle_state=-1; last_note_after_bank=-1;
// Color
last_color_idx=-1; last_rgb=-1; last_R=-1; last_G=-1; last_B=-1; last_Rlsb=-1; last_Glsb=-1; last_Blsb=-1;
// OUT SysEx (store last frame)
syxN=16; syx0=0;syx1=0;syx2=0;syx3=0;syx4=0;syx5=0;syx6=0;syx7=0;syx8=0;syx9=0;syx10=0;syx11=0;syx12=0;syx13=0;syx14=0;syx15=0;

// -------------------------
// @block — react to Note On > 0 on selected channel; SysEx-only OUT
// -------------------------
@block
while ( midirecv(offset, msg1, msg2, msg3) ?
(
  status = msg1 & $xF0;
  ch     = (msg1 & $x0F);
  d1 =  msg2      & 0x7F; // note/cc
  d2 =  msg3      & 0x7F; // vel/value

  // IN log (like ref script)
  last_in_status=status; last_in_ch=ch; last_in_d1=d1; last_in_d2=d2;

  // Only NoteOn with vel>0 on the selected input channel
  reacts = ( (slider4 == ch) ? 1 : 0 ); // slider4 is 0..15 == Ch1..Ch16 (ch is 0..15)
  (status==0x90) && (d2>0) && reacts ? (

    // Note Shift
    last_shift_orig = d1;
    last_shift_amt  = slider5|0;
    note = last_shift_orig + last_shift_amt;
    note < 0 ? note = 0 : note > 127 ? note = 127;
    last_shift_new = note;

    // Bank range (16 pads)
    bank_offset = slider1 * 16;
    (note >= bank_offset) && (note < bank_offset + 16) ? (

      pad_index = note - bank_offset;
      slider2   = pad_index + bank_offset;       // show 0..63 if your mapping uses that
      last_pad_index = pad_index;
      last_note_after_bank = note;

      // Toggle state per pad
      val = pad_index == 0 ? pad0 :
            pad_index == 1 ? pad1 :
            pad_index == 2 ? pad2 :
            pad_index == 3 ? pad3 :
            pad_index == 4 ? pad4 :
            pad_index == 5 ? pad5 :
            pad_index == 6 ? pad6 :
            pad_index == 7 ? pad7 :
            pad_index == 8 ? pad8 :
            pad_index == 9 ? pad9 :
            pad_index == 10 ? pad10 :
            pad_index == 11 ? pad11 :
            pad_index == 12 ? pad12 :
            pad_index == 13 ? pad13 :
            pad_index == 14 ? pad14 :
            pad_index == 15 ? pad15 : 0;

      new_val = val ? 0 : 1;
      last_toggle_state = new_val;

      // Store back
      pad_index == 0  ? pad0  = new_val :
      pad_index == 1  ? pad1  = new_val :
      pad_index == 2  ? pad2  = new_val :
      pad_index == 3  ? pad3  = new_val :
      pad_index == 4  ? pad4  = new_val :
      pad_index == 5  ? pad5  = new_val :
      pad_index == 6  ? pad6  = new_val :
      pad_index == 7  ? pad7  = new_val :
      pad_index == 8  ? pad8  = new_val :
      pad_index == 9  ? pad9  = new_val :
      pad_index == 10 ? pad10 = new_val :
      pad_index == 11 ? pad11 = new_val :
      pad_index == 12 ? pad12 = new_val :
      pad_index == 13 ? pad13 = new_val :
      pad_index == 14 ? pad14 = new_val :
      pad_index == 15 ? pad15 = new_val;

      // Color from palette
      rgb = color[slider3];
      R = (rgb & 0xFF0000) >> 16;
      G = (rgb & 0x00FF00) >> 8;
      B = (rgb & 0x0000FF);

      sysexR = R * 127 / 255;
      sysexG = G * 127 / 255;
      sysexB = B * 127 / 255;

      last_color_idx = slider3|0;
      last_rgb = rgb;
      last_R = R; last_G = G; last_B = B;
      last_Rlsb = sysexR; last_Glsb = sysexG; last_Blsb = sysexB;

      // Build SysEx frame (APC Mini mk2 RGB lighting)
      sysex[0] = 0xF0;
      sysex[1] = 0x47; // Manufacturer
      sysex[2] = 0x7F; // Device ID (broadcast)
      sysex[3] = 0x4F; // Product model ID
      sysex[4] = 0x24; // RGB Color Lighting
      sysex[5] = 0x00; // length MSB
      sysex[6] = 0x08; // length LSB for 1 pad
      sysex[7] = note; // start pad
      sysex[8] = note; // end pad

      (new_val == 1) ? (
        sysex[9]  = 0;          sysex[10] = sysexR;
        sysex[11] = 0;          sysex[12] = sysexG;
        sysex[13] = 0;          sysex[14] = sysexB;
      ) : (
        sysex[9]  = 0;          sysex[10] = 0;
        sysex[11] = 0;          sysex[12] = 0;
        sysex[13] = 0;          sysex[14] = 0;
      );

      sysex[15] = 0xF7;

      // Send ONLY SysEx
      midisend_buf(offset, sysex, sysex_len);

      // Store last SysEx frame for OUT log
      syxN = sysex_len;
      syx0=sysex[0]; syx1=sysex[1]; syx2=sysex[2]; syx3=sysex[3]; syx4=sysex[4];
      syx5=sysex[5]; syx6=sysex[6]; syx7=sysex[7]; syx8=sysex[8]; syx9=sysex[9];
      syx10=sysex[10]; syx11=sysex[11]; syx12=sysex[12]; syx13=sysex[13]; syx14=sysex[14]; syx15=sysex[15];
    );
  );

  // Do NOT pass anything thru
  1;
) : 0 );

// -------------------------
// @gfx — simple header + logs (left aligned), color preview
// -------------------------
@gfx
margin=10; pad=6;
gfx_set(0,0,0); gfx_rect(0,0,gfx_w,gfx_h);
gfx_setfont(1,"",14);

// Header
sprintf(#hdr,"APC Mini mk2 RGB Toggle  |  Bank:%d  InCh:%d  ColorIdx:%d",
        slider1+1, slider4+1, slider3);
gfx_r=gfx_g=gfx_b=1; gfx_x=margin; gfx_y=margin; gfx_drawstr(#hdr);

// Color preview (top-right)
col = color[slider3];
r = ((col>>16)&0xFF)/255.0;
g = ((col>>8)&0xFF)/255.0;
b = (col&0xFF)/255.0;
box = 60; bx = gfx_w - margin - box; by = margin;
gfx_set(r,g,b); gfx_rect(bx,by,box,box);
gfx_set(1,1,1);

// IN log (like ref script)
(last_in_status>=0)?
(
  #it="";
  (last_in_status==0x80)?strcpy(#it,"IN: NoteOff")
  : (last_in_status==0x90)?strcpy(#it,"IN: NoteOn")
  : (last_in_status==0xB0)?strcpy(#it,"IN: CC")
  : (last_in_status==0xE0)?strcpy(#it,"IN: Pitch")
  : sprintf(#it,"IN: 0x%02X", last_in_status);

  sprintf(#inln,"%s  Ch %d  d1=%3d  d2=%3d", #it, last_in_ch+1, last_in_d1, last_in_d2);
) : (
  strcpy(#inln,"IN: —")
);
gfx_x=margin; gfx_y=margin+20; gfx_drawstr(#inln);

// NoteShift line
(last_shift_orig>=0)?
(
  sprintf(#shiftln,"NoteShift: original=%d  +  shift=%d  =>  shifted=%d",
          last_shift_orig, last_shift_amt, last_shift_new);
) : (
  strcpy(#shiftln,"NoteShift: —")
);
gfx_x=margin; gfx_y=margin+20+16; gfx_drawstr(#shiftln);

// Last toggle line
(last_pad_index>=0)?
(
  sprintf(#tglln,"Last toggle: Bank %d  Pad %d  Note %d  -> %s",
          slider1+1, last_pad_index, last_note_after_bank, (last_toggle_state?"ON":"OFF"));
) : (
  strcpy(#tglln,"Last toggle: —")
);
gfx_x=margin; gfx_y=margin+20+16+16; gfx_drawstr(#tglln);

// Color line
(last_color_idx>=0)?
(
  sprintf(#col1,"Color: idx=%d  HEX:#%06X  R:%3d G:%3d B:%3d  (LSB:%3d,%3d,%3d)",
          last_color_idx, last_rgb, last_R, last_G, last_B, last_Rlsb, last_Glsb, last_Blsb);
) : (
  strcpy(#col1,"Color: —")
);
gfx_x=margin; gfx_y=margin+20+16+16+16; gfx_drawstr(#col1);

// OUT: SysEx summary
(syxN>0)?
(
  strcpy(#ot,"OUT: SysEx RGB Lighting  len=16");
) : (
  strcpy(#ot,"OUT: —")
);
gfx_x=margin; gfx_y=margin+20+16+16+16+16; gfx_drawstr(#ot);

// OUT: SysEx hex line
(syxN==16)?
(
  sprintf(#syx,
    "SYSEX: %02X %02X %02X %02X  %02X  %02X %02X  %02X %02X  %02X %02X %02X %02X %02X %02X  %02X",
    syx0&0xFF, syx1&0xFF, syx2&0xFF, syx3&0xFF, syx4&0xFF, syx5&0xFF, syx6&0xFF,
    syx7&0xFF, syx8&0xFF, syx9&0xFF, syx10&0xFF, syx11&0xFF, syx12&0xFF, syx13&0xFF, syx14&0xFF, syx15&0xFF
  );
) : (
  strcpy(#syx,"SYSEX: —")
);
gfx_x=margin; gfx_y=margin+20+16+16+16+16+16; gfx_drawstr(#syx);

gfx_dirty=1;
