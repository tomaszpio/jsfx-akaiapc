desc:APC Mini Pad RGB Toggle — 16-slot array state (like "Note On Toggler"), Offset window, NOTE ON toggle, SysEx-only, CC120/123 reset, left-aligned logs + 4x4 grid

// -------------------------
// Sliders
// -------------------------
slider1:0<0,111,1>Pad Window Offset (start note ID)
slider2:0<0,63,1>Last Triggered Pad (readonly)
slider3:0<0,127,1>Pad Color Index
slider4:0<0,15,1>Input MIDI Channel (0=Ch1 ... 15=Ch16)
slider5:0<-127,127,1>Note Shift (Semitones) // info-only (mapping uses raw note)

// -------------------------
// @init — array state[] managed exactly like "Note On Toggler"
// -------------------------
@init
gfx_clear = 1;
sysex_len = 16;

SLOTS = 16;                    // 4x4 window
STATE_BASE = 0; STATE_SIZE = SLOTS;
state = STATE_BASE;            // scalar for logs only; array indices are 0..SLOTS-1

// clear array state[0..15] to 0 (OFF)
i=0; loop(STATE_SIZE, state[i]=0; i+=1;);

// logs / diagnostics (simple, left-aligned)
last_in_status=-1; last_in_ch=-1; last_in_d1=-1; last_in_d2=-1;
last_pad_index=-1; last_pad_id=-1;
last_val_before=-1; last_newstate=-1; last_after_write=-1;
last_reset_cc=-1; last_reset_ch=-1;

last_color_idx=-1; last_rgb=-1; last_R=-1; last_G=-1; last_B=-1;
last_Rlsb=-1; last_Glsb=-1; last_Blsb=-1;

last_shift_orig=-1; last_shift_amt=0; last_shift_new=-1;

// snapshot of last OUT SysEx (for display)
syxN=0;
syx0=syx1=syx2=syx3=syx4=syx5=syx6=syx7=syx8=syx9=0;
syx10=syx11=syx12=syx13=syx14=syx15=0;

// -------------------------
// Full color table (0..127) in 0xRRGGBB
// -------------------------
color[0]=0x000000;  color[1]=0x1E1E1E;  color[2]=0x7F7F7F;  color[3]=0xFFFFFF;  color[4]=0xFF4C4C;
color[5]=0xFF0000;  color[6]=0x590000;  color[7]=0x190000;  color[8]=0xFFBD6C;  color[9]=0xFF5400;
color[10]=0x591D00; color[11]=0x271B00; color[12]=0xFFFF4C; color[13]=0xFFFF00; color[14]=0x595900;
color[15]=0x191900; color[16]=0x88FF4C; color[17]=0x54FF00; color[18]=0x1D5900; color[19]=0x142B00;
color[20]=0x4CFF4C; color[21]=0x00FF00; color[22]=0x005900; color[23]=0x001900; color[24]=0x4CFF5E;
color[25]=0x00FF19; color[26]=0x00590D; color[27]=0x001902; color[28]=0x4CFF88; color[29]=0x00FF55;
color[30]=0x00591D; color[31]=0x001F12; color[32]=0x4CFFB7; color[33]=0x00FF99; color[34]=0x005935;
color[35]=0x001912; color[36]=0x4CC3FF; color[37]=0x00A9FF; color[38]=0x004152; color[39]=0x001019;
color[40]=0x4C88FF; color[41]=0x0055FF; color[42]=0x001D59; color[43]=0x000819; color[44]=0x4C4CFF;
color[45]=0x0000FF; color[46]=0x000059; color[47]=0x000019; color[48]=0x874CFF; color[49]=0x5400FF;
color[50]=0x190064; color[51]=0x0F0030; color[52]=0xFF4CFF; color[53]=0xFF00FF; color[54]=0x590059;
color[55]=0x190019; color[56]=0xFF4C87; color[57]=0xFF0054; color[58]=0x59001D; color[59]=0x220013;
color[60]=0xFF1500; color[61]=0x993500; color[62]=0x795100; color[63]=0x436400; color[64]=0x033900;
color[65]=0x005735; color[66]=0x00547F; color[67]=0x0000FF; color[68]=0x00454F; color[69]=0x2500CC;
color[70]=0x7F7F7F; color[71]=0x202020; color[72]=0xFF0000; color[73]=0xBDFF2D; color[74]=0xAFED06;
color[75]=0x64FF09; color[76]=0x108B00; color[77]=0x00FF87; color[78]=0x00A9FF; color[79]=0x002AFF;
color[80]=0x3F00FF; color[81]=0x7A00FF; color[82]=0xB21A7D; color[83]=0x402100; color[84]=0xFF4A00;
color[85]=0x88E106; color[86]=0x72FF15; color[87]=0x00FF00; color[88]=0x3BFF26; color[89]=0x59FF71;
color[90]=0x38FFCC; color[91]=0x5B8AFF; color[92]=0x3151C6; color[93]=0x877FE9; color[94]=0xD31DFF;
color[95]=0xFF005D; color[96]=0xFF7F00; color[97]=0xB9B000; color[98]=0x835D07; color[99]=0x392B00;
color[100]=0x144C10; color[101]=0x1AD000; color[102]=0x0D5038; color[103]=0x15152A; color[104]=0x16205A;
color[105]=0x693C1C; color[106]=0xA8000A; color[107]=0xDE513D; color[108]=0xD86A1C; color[109]=0xFFE126;
color[110]=0x9EE12F; color[111]=0x67B50F; color[112]=0x1E1E30; color[113]=0xDCFF6B; color[114]=0x80FFBD;
color[115]=0x9A99FF; color[116]=0x8E66FF; color[117]=0x404040; color[118]=0x757575; color[119]=0xE0FFFF;
color[120]=0xA00000; color[121]=0x350000; color[122]=0x1AD000; color[123]=0x074200; color[124]=0xB9B000;
color[125]=0x3F3100; color[126]=0xB35F00; color[127]=0x4B1502;

// -------------------------
// Helper: send OFF to a hardware pad id (0..63) via SysEx
// -------------------------
function send_pad_off(off, pid)(
  sysex[0]=$xF0; sysex[1]=$x47; sysex[2]=$x7F; sysex[3]=$x4F; sysex[4]=$x24;
  sysex[5]=$x00; sysex[6]=$x08;
  sysex[7]=pid & $x7F; sysex[8]=pid & $x7F;
  sysex[9]=0; sysex[10]=0; sysex[11]=0; sysex[12]=0; sysex[13]=0; sysex[14]=0;
  sysex[15]=$xF7;
  midisend_buf(off, sysex, 16);
);

// -------------------------
// @block — toggle ONLY on NOTE ON > 0; RESET on CC120/123; NO THRU
// -------------------------
@block
while (midirecv(offset, msg1, msg2, msg3)) (
  status = msg1 & $xF0;
  in_ch  = msg1 & $x0F;
  d1 = msg2 & $x7F;   // note/cc
  d2 = msg3 & $x7F;   // velocity/value

  // IN log (raw)
  last_in_status=status; last_in_ch=in_ch; last_in_d1=d1; last_in_d2=d2;

  // --- RESET: All Sound Off (120) / All Notes Off (123) on selected channel ---
  (status==$xB0) && (in_ch==slider4) ? (
    (d1==120) || (d1==123) ? (
      i=0; loop(STATE_SIZE, state[i]=0; i+=1;);   // clear state[] here
      // turn OFF all hardware pads (0..63) for safety
      pid=0; loop(64, send_pad_off(offset, pid); pid+=1;);
      last_reset_cc=d1; last_reset_ch=in_ch;
    );
  );

  // --- TOGGLE: ONLY Note On with vel>0; ONLY notes from the 16-slot window ---
  (status==$x90) && (d2>0) && (in_ch==slider4) ? (
    offset16 = slider1|0;
    slot = d1 - offset16;
    (slot >= 0) && (slot < SLOTS) ? (
      // READ -> TOGGLE -> WRITE (exactly like Note On Toggler)
      val_before = state[slot] ? 1 : 0;
      newstate   = val_before ? 0 : 1;
      state[slot]= newstate;

      // simple logs
      last_pad_index = slot;
      last_pad_id    = d1;
      slider2        = d1;
      last_val_before= val_before;
      last_newstate  = newstate;
      last_after_write = state[slot];

      // --- Palette -> RGB (0..255) and -> 0..127 (integers only) ---
      rgb = color[slider3];
      R = (rgb & $xFF0000) >> 16;
      G = (rgb & $x00FF00) >> 8;
      B = (rgb & $x0000FF);
      sysexR = R * 127 / 255;
      sysexG = G * 127 / 255;
      sysexB = B * 127 / 255;
      last_color_idx=slider3; last_rgb=rgb;
      last_R=R; last_G=G; last_B=B;
      last_Rlsb=sysexR; last_Glsb=sysexG; last_Blsb=sysexB;

      // --- SysEx frame (Akai APC Mini mk2 RGB: 47 7F 4F 24) ---
      sysex[0]=$xF0; sysex[1]=$x47; sysex[2]=$x7F; sysex[3]=$x4F; sysex[4]=$x24;
      sysex[5]=$x00; sysex[6]=$x08;            // 8 data bytes
      sysex[7]=d1 & $x7F; sysex[8]=d1 & $x7F;  // start/end pad = same ID

      // === EXACT COLOR-SETTING BLOCK (as requested) ===
      (newstate == 1) ? (
        // Use selected color for ON state
        sysex[9]  = 0;          // Red MSB
        sysex[10] = sysexR;     // Red LSB
        sysex[11] = 0;          // Green MSB
        sysex[12] = sysexG;     // Green LSB
        sysex[13] = 0;          // Blue MSB
        sysex[14] = sysexB;     // Blue LSB
        sysex[15] = $xF7;
        midisend_buf(offset, sysex, sysex_len);
      ) : (
        // Off state
        sysex[9] = 0;
        sysex[10] = 0;
        sysex[11] = 0;
        sysex[12] = 0;
        sysex[13] = 0;
        sysex[14] = 0;
        sysex[15] = $xF7;
        midisend_buf(offset, sysex, sysex_len);
      );

      // store last OUT snapshot
      syxN=sysex_len;
      syx0=sysex[0]; syx1=sysex[1]; syx2=sysex[2]; syx3=sysex[3]; syx4=sysex[4];
      syx5=sysex[5]; syx6=sysex[6]; syx7=sysex[7]; syx8=sysex[8]; syx9=sysex[9];
      syx10=sysex[10]; syx11=sysex[11]; syx12=sysex[12]; syx13=sysex[13]; syx14=sysex[14]; syx15=sysex[15];

      // Note Shift (info-only)
      last_shift_orig = d1; last_shift_amt = slider5;
      shifted_note = last_shift_orig + last_shift_amt;
      (shifted_note<0)?shifted_note=0:(shifted_note>127)?shifted_note=127;
      last_shift_new = shifted_note;
    );
  );

  // swallow everything: SysEx only (no pass-through)
);

// -------------------------
// @gfx — simple left-aligned logs + color preview + 4×4 grid
// -------------------------
@gfx
margin=10; lineh=18;
gfx_set(0,0,0); gfx_rect(0,0,gfx_w,gfx_h);
gfx_setfont(1,"",14);

// Header
sprintf(#hdr,"APC Mini mk2 RGB Toggle | Offset:%d..%d  InCh:%d  ColorIdx:%d",
        slider1, slider1+15, slider4+1, slider3);
gfx_r=gfx_g=gfx_b=1; gfx_x=margin; gfx_y=margin; gfx_drawstr(#hdr);

// Color preview (top-right)
col = color[slider3];
pr = ((col>>16)&255)/255.0; pg = ((col>>8)&255)/255.0; pb = (col&255)/255.0;
box=60; bx=gfx_w - margin - box; by=margin;
gfx_set(pr,pg,pb); gfx_rect(bx,by,box,box); gfx_set(1,1,1);

// IN log
(last_in_status>=0)?
(
  #it="";
  (last_in_status==$x80)?strcpy(#it,"IN: NoteOff")
  : (last_in_status==$x90)?strcpy(#it,"IN: NoteOn")
  : (last_in_status==$xB0)?strcpy(#it,"IN: CC")
  : sprintf(#it,"IN: 0x%02X", last_in_status);
  sprintf(#inln,"%s  Ch %d  d1=%3d  d2=%3d", #it, last_in_ch+1, last_in_d1, last_in_d2);
) : ( strcpy(#inln,"IN: —") );
gfx_x=margin; gfx_y=margin+22; gfx_drawstr(#inln);

// Toggle math
sprintf(#tm,"Toggle: val(before)=%d  newstate=%d  after_write=%d",
        last_val_before, last_newstate, last_after_write);
gfx_x=margin; gfx_y=margin+22+lineh; gfx_drawstr(#tm);

// Color report
(last_color_idx>=0)?
( sprintf(#coline,"Color: idx=%d  HEX:#%06X  R:%3d G:%3d B:%3d  (LSB:%3d,%3d,%3d)",
          last_color_idx, last_rgb, last_R, last_G, last_B, last_Rlsb, last_Glsb, last_Blsb) )
: ( strcpy(#coline,"Color: —") );
gfx_x=margin; gfx_y=margin+22+2*lineh; gfx_drawstr(#coline);

// Last reset
(last_reset_cc>=0)?
( sprintf(#rst,"Last reset: CC %d on Ch %d (state cleared, OFF to pads 0..63)", last_reset_cc, last_reset_ch+1) )
: ( strcpy(#rst,"Last reset: —") );
gfx_x=margin; gfx_y=margin+22+3*lineh; gfx_drawstr(#rst);

// OUT summary + hex frame
(syxN==16)? ( strcpy(#out,"OUT: SysEx RGB Lighting  len=16") ) : ( strcpy(#out,"OUT: —") );
gfx_x=margin; gfx_y=margin+22+4*lineh; gfx_drawstr(#out);
(syxN==16)?
(
  sprintf(#syx,"SYSEX: %02X %02X %02X %02X  %02X  %02X %02X  %02X %02X  %02X %02X %02X %02X %02X %02X  %02X",
    syx0&255, syx1&255, syx2&255, syx3&255, syx4&255, syx5&255, syx6&255,
    syx7&255, syx8&255, syx9&255, syx10&255, syx11&255, syx12&255, syx13&255, syx14&255, syx15&255 )
) : ( strcpy(#syx,"SYSEX: —") );
gfx_x=margin; gfx_y=margin+22+5*lineh; gfx_drawstr(#syx);

// State dump (array 0..15)
#dump=""; i=0; loop(STATE_SIZE, v=(state[i]?1:0); (i==0)?sprintf(#dump,"%d",v):sprintf(#dump,"%s %d",#dump,v); i+=1;);
sprintf(#sd,"state[16]: %s   last_pad_index=%d  last_pad_id=%d  offset=%d",
        #dump, last_pad_index, last_pad_id, slider1|0);
gfx_x=margin; gfx_y=margin+22+6*lineh; gfx_drawstr(#sd);

// ---------- 4x4 GRID ----------
top = margin + 22 + 7*lineh + 6;
cols=4; rows=4;
avail_w = max(100, gfx_w - 2*margin);
avail_h = max(100, gfx_h - top - margin);
cell_w = floor(avail_w/cols);
cell_h = floor(avail_h/rows);
grid_w = cell_w*cols; grid_h = cell_h*rows;
grid_x0 = margin + floor((avail_w - grid_w) * 0.5);
grid_y0 = top;

on_r = pr * 0.9; on_g = pg * 0.9; on_b = pb * 0.9;

i=0; loop(SLOTS,
  row = floor(i/cols);
  col = i % cols;
  gx = grid_x0 + col * cell_w;
  gy = grid_y0 + row * cell_h;

  on = state[i] ? 1 : 0;

  (on ? gfx_set(on_r,on_g,on_b) : gfx_set(0.12,0.12,0.12));
  gfx_rect(gx,gy,cell_w-2,cell_h-2);

  gfx_set(0.6,0.6,0.6);
  gfx_line(gx,gy,gx+cell_w-2,gy);
  gfx_line(gx,gy,gx,gy+cell_h-2);
  gfx_line(gx+cell_w-2,gy,gx+cell_w-2,gy+cell_h-2);
  gfx_line(gx,gy+cell_h-2,gx+cell_w-2,gy+cell_h-2);

  (last_pad_index == i) ? (
    gfx_set(1,1,1);
    gfx_line(gx+1,gy+1,gx+cell_w-3,gy+1);
    gfx_line(gx+1,gy+1,gx+1,gy+cell_h-3);
    gfx_line(gx+cell_w-3,gy+1,gx+cell_w-3,gy+cell_h-3);
    gfx_line(gx+1,gy+cell_h-3,gx+cell_w-3,gy+cell_h-3);
  );

  gfx_set(1,1,1);
  gfx_x = gx + 6; gfx_y = gy + 6;
  abs_id = (slider1|0) + i;
  sprintf(#lab,"P%02d  ID %02d", i, abs_id);
  gfx_drawstr(#lab);

  i+=1;
);

gfx_dirty=1;
