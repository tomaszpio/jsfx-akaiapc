desc: MIDI sustain hold - hold multiple notes while sustain pedal (CC64) is pressed
author: tomaszpio
version: 1.2.0
about:
  This JSFX plugin implements a sustain-hold behaviour similar to an
  instrument sustain pedal: when sustain (MIDI CC64) is held (value > 0),
  incoming Note Off messages are intercepted and the notes are kept (held).
  When the pedal is released (CC64 returns to 0), all previously held notes are
  released (Note Off messages are sent).

  FEATURES:
  - Works in Omni mode (Channel = 0) or on a single MIDI channel (1..16).
  - Holds any number of notes simultaneously while sustain is pressed.
  - CC64 messages and all non-note messages are forwarded unchanged.
  - Sustain engages at values > 0 and releases when it returns to 0.

  USAGE:
  - Put this JSFX between your MIDI input and instrument in REAPER so it
    can intercept MIDI and forward events to the instrument.
  - Use slider `Channel` to select 0 (omni) or a single MIDI channel.
  - Press and hold your sustain pedal (CC64 > 0) — Note Offs will be
    suppressed and notes will keep sounding. Release the pedal to release
    all held notes at once.

slider1:0<0,16,1>Channel (0=omni)

in_pin:none
out_pin:none

@init
// Track up to 10 simultaneous notes using dedicated variables (no arrays).
slot0_note = -1; slot0_chan = 0; slot0_pressed = 0; slot0_sustain = 0;
slot1_note = -1; slot1_chan = 0; slot1_pressed = 0; slot1_sustain = 0;
slot2_note = -1; slot2_chan = 0; slot2_pressed = 0; slot2_sustain = 0;
slot3_note = -1; slot3_chan = 0; slot3_pressed = 0; slot3_sustain = 0;
slot4_note = -1; slot4_chan = 0; slot4_pressed = 0; slot4_sustain = 0;
slot5_note = -1; slot5_chan = 0; slot5_pressed = 0; slot5_sustain = 0;
slot6_note = -1; slot6_chan = 0; slot6_pressed = 0; slot6_sustain = 0;
slot7_note = -1; slot7_chan = 0; slot7_pressed = 0; slot7_sustain = 0;
slot8_note = -1; slot8_chan = 0; slot8_pressed = 0; slot8_sustain = 0;
slot9_note = -1; slot9_chan = 0; slot9_pressed = 0; slot9_sustain = 0;
pedal_down = 0;

@slider
// Channel mapping:
// slider1 = 0  -> omni (chan = -1, so all channels match)
// slider1 = 1–16 -> MIDI channels 0–15
s1   = slider1|0;
chan = s1 ? (s1 - 1) : -1;

@block
while (midirecv(ts, msg, msg23)) (
  status = msg & $xf0;          // message type
  ch     = msg & $x0f;          // MIDI channel 0..15
  d1     = msg23 & $xff;        // data1 (note number or CC number)
  d2     = (msg23/256) & $xff;  // data2 (velocity or CC value)

  in_chan = (chan < 0) || (ch == chan);
  is_note = (status == $x90) || (status == $x80);

  // Sustain pedal handling (CC64)
  status == $xb0 && d1 == 64 ? (
    // Forward the CC message unchanged
    midisend(ts, msg, msg23);

    sustain_on = d2 > 0;

    // Pedal release: flush held notes
    (pedal_down && !sustain_on) ? (
      slot0_sustain ? (midisend(ts, $x80 + slot0_chan, slot0_note); slot0_sustain = 0; slot0_pressed ? 0 : slot0_note = -1;);
      slot1_sustain ? (midisend(ts, $x80 + slot1_chan, slot1_note); slot1_sustain = 0; slot1_pressed ? 0 : slot1_note = -1;);
      slot2_sustain ? (midisend(ts, $x80 + slot2_chan, slot2_note); slot2_sustain = 0; slot2_pressed ? 0 : slot2_note = -1;);
      slot3_sustain ? (midisend(ts, $x80 + slot3_chan, slot3_note); slot3_sustain = 0; slot3_pressed ? 0 : slot3_note = -1;);
      slot4_sustain ? (midisend(ts, $x80 + slot4_chan, slot4_note); slot4_sustain = 0; slot4_pressed ? 0 : slot4_note = -1;);
      slot5_sustain ? (midisend(ts, $x80 + slot5_chan, slot5_note); slot5_sustain = 0; slot5_pressed ? 0 : slot5_note = -1;);
      slot6_sustain ? (midisend(ts, $x80 + slot6_chan, slot6_note); slot6_sustain = 0; slot6_pressed ? 0 : slot6_note = -1;);
      slot7_sustain ? (midisend(ts, $x80 + slot7_chan, slot7_note); slot7_sustain = 0; slot7_pressed ? 0 : slot7_note = -1;);
      slot8_sustain ? (midisend(ts, $x80 + slot8_chan, slot8_note); slot8_sustain = 0; slot8_pressed ? 0 : slot8_note = -1;);
      slot9_sustain ? (midisend(ts, $x80 + slot9_chan, slot9_note); slot9_sustain = 0; slot9_pressed ? 0 : slot9_note = -1;);
    );

    // Update pedal state
    pedal_down = sustain_on;
  ) : (
    // Note processing
    is_note && in_chan ? (
      note = d1;
      vel  = d2;

      // Find an existing slot for this note/channel and remember the first empty slot
      slot_idx = -1;
      empty_idx = -1;

      (slot_idx < 0) && (slot0_note == note) && (slot0_chan == ch) ? slot_idx = 0;
      (slot_idx < 0) && (slot1_note == note) && (slot1_chan == ch) ? slot_idx = 1;
      (slot_idx < 0) && (slot2_note == note) && (slot2_chan == ch) ? slot_idx = 2;
      (slot_idx < 0) && (slot3_note == note) && (slot3_chan == ch) ? slot_idx = 3;
      (slot_idx < 0) && (slot4_note == note) && (slot4_chan == ch) ? slot_idx = 4;
      (slot_idx < 0) && (slot5_note == note) && (slot5_chan == ch) ? slot_idx = 5;
      (slot_idx < 0) && (slot6_note == note) && (slot6_chan == ch) ? slot_idx = 6;
      (slot_idx < 0) && (slot7_note == note) && (slot7_chan == ch) ? slot_idx = 7;
      (slot_idx < 0) && (slot8_note == note) && (slot8_chan == ch) ? slot_idx = 8;
      (slot_idx < 0) && (slot9_note == note) && (slot9_chan == ch) ? slot_idx = 9;

      (empty_idx < 0) && (slot0_note < 0) ? empty_idx = 0;
      (empty_idx < 0) && (slot1_note < 0) ? empty_idx = 1;
      (empty_idx < 0) && (slot2_note < 0) ? empty_idx = 2;
      (empty_idx < 0) && (slot3_note < 0) ? empty_idx = 3;
      (empty_idx < 0) && (slot4_note < 0) ? empty_idx = 4;
      (empty_idx < 0) && (slot5_note < 0) ? empty_idx = 5;
      (empty_idx < 0) && (slot6_note < 0) ? empty_idx = 6;
      (empty_idx < 0) && (slot7_note < 0) ? empty_idx = 7;
      (empty_idx < 0) && (slot8_note < 0) ? empty_idx = 8;
      (empty_idx < 0) && (slot9_note < 0) ? empty_idx = 9;

      (slot_idx < 0) && (empty_idx >= 0) ? slot_idx = empty_idx;

      // Initialize the slot when it is first claimed
      slot_idx == 0 ? (slot0_note = note; slot0_chan = ch;);
      slot_idx == 1 ? (slot1_note = note; slot1_chan = ch;);
      slot_idx == 2 ? (slot2_note = note; slot2_chan = ch;);
      slot_idx == 3 ? (slot3_note = note; slot3_chan = ch;);
      slot_idx == 4 ? (slot4_note = note; slot4_chan = ch;);
      slot_idx == 5 ? (slot5_note = note; slot5_chan = ch;);
      slot_idx == 6 ? (slot6_note = note; slot6_chan = ch;);
      slot_idx == 7 ? (slot7_note = note; slot7_chan = ch;);
      slot_idx == 8 ? (slot8_note = note; slot8_chan = ch;);
      slot_idx == 9 ? (slot9_note = note; slot9_chan = ch;);

      status == $x90 && vel > 0 ? (
        // New note on: forward and mark as active
        midisend(ts, msg, msg23);
        slot_idx == 0 ? (slot0_pressed = 1; slot0_sustain = 0;);
        slot_idx == 1 ? (slot1_pressed = 1; slot1_sustain = 0;);
        slot_idx == 2 ? (slot2_pressed = 1; slot2_sustain = 0;);
        slot_idx == 3 ? (slot3_pressed = 1; slot3_sustain = 0;);
        slot_idx == 4 ? (slot4_pressed = 1; slot4_sustain = 0;);
        slot_idx == 5 ? (slot5_pressed = 1; slot5_sustain = 0;);
        slot_idx == 6 ? (slot6_pressed = 1; slot6_sustain = 0;);
        slot_idx == 7 ? (slot7_pressed = 1; slot7_sustain = 0;);
        slot_idx == 8 ? (slot8_pressed = 1; slot8_sustain = 0;);
        slot_idx == 9 ? (slot9_pressed = 1; slot9_sustain = 0;);
      ) : (
        // Note Off (0x80) or Note On with vel = 0
        slot_idx == 0 ? slot0_pressed = 0;
        slot_idx == 1 ? slot1_pressed = 0;
        slot_idx == 2 ? slot2_pressed = 0;
        slot_idx == 3 ? slot3_pressed = 0;
        slot_idx == 4 ? slot4_pressed = 0;
        slot_idx == 5 ? slot5_pressed = 0;
        slot_idx == 6 ? slot6_pressed = 0;
        slot_idx == 7 ? slot7_pressed = 0;
        slot_idx == 8 ? slot8_pressed = 0;
        slot_idx == 9 ? slot9_pressed = 0;

        pedal_down && (slot_idx >= 0) ? (
          // With pedal down, block Note Off and mark to release later
          slot_idx == 0 ? slot0_sustain = 1;
          slot_idx == 1 ? slot1_sustain = 1;
          slot_idx == 2 ? slot2_sustain = 1;
          slot_idx == 3 ? slot3_sustain = 1;
          slot_idx == 4 ? slot4_sustain = 1;
          slot_idx == 5 ? slot5_sustain = 1;
          slot_idx == 6 ? slot6_sustain = 1;
          slot_idx == 7 ? slot7_sustain = 1;
          slot_idx == 8 ? slot8_sustain = 1;
          slot_idx == 9 ? slot9_sustain = 1;
        ) : (
          // No sustain: forward immediately
          midisend(ts, msg, msg23);
          // Free the slot if no sustain keeps it around
          (slot_idx == 0) && (slot0_sustain == 0) ? (slot0_note = -1; slot0_chan = 0;);
          (slot_idx == 1) && (slot1_sustain == 0) ? (slot1_note = -1; slot1_chan = 0;);
          (slot_idx == 2) && (slot2_sustain == 0) ? (slot2_note = -1; slot2_chan = 0;);
          (slot_idx == 3) && (slot3_sustain == 0) ? (slot3_note = -1; slot3_chan = 0;);
          (slot_idx == 4) && (slot4_sustain == 0) ? (slot4_note = -1; slot4_chan = 0;);
          (slot_idx == 5) && (slot5_sustain == 0) ? (slot5_note = -1; slot5_chan = 0;);
          (slot_idx == 6) && (slot6_sustain == 0) ? (slot6_note = -1; slot6_chan = 0;);
          (slot_idx == 7) && (slot7_sustain == 0) ? (slot7_note = -1; slot7_chan = 0;);
          (slot_idx == 8) && (slot8_sustain == 0) ? (slot8_note = -1; slot8_chan = 0;);
          (slot_idx == 9) && (slot9_sustain == 0) ? (slot9_note = -1; slot9_chan = 0;);
        );
      );
    ) : (
      // Non-note or other channel: forward unchanged
      midisend(ts, msg, msg23);
    );
  );
);