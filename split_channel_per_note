desc: MIDI Keyboard Split Filter
author: ChatGPT (JSFX)
version: 1.0.0
about:
  Filters incoming MIDI notes by split key and input channel:
  - Lower zone notes accepted only from Low Input Channel
  - Upper zone notes accepted only from High Input Channel
  - Accepted notes routed to Output Channel
  Tracks per-note zone stack for consistency.

slider1:60<0,127,1>Split note (MIDI #)
slider2:1<1,16,1>Output channel
slider3:1<1,16,1>Low zone input channel
slider4:2<1,16,1>High zone input channel
slider5:0<0,1,1>Other MIDI (0=Pass, 1=Block)

@init
// Per-note zone stack to keep Note Off consistent after changing split.
// zone: 0 = low, 1 = high
STACK_MAX = 16;
memset(stack_sp, 0, 128);         // stack pointers per note
// stack_data indexed as: (note*STACK_MAX + depth)
memset(stack_data, 0, 128*STACK_MAX);

function push_zone(note, zone) local(sp, idx) (
  sp = stack_sp[note];
  sp < STACK_MAX ? (
    idx = note*STACK_MAX + sp;
    stack_data[idx] = zone;
    stack_sp[note] = sp + 1;
  ) : (
    // overflow: drop newest push (safe fallback)
    // alternatively could shift, but keep it simple
    0;
  );
);

function pop_zone(note) local(sp, idx, zone) (
  sp = stack_sp[note];
  sp > 0 ? (
    sp -= 1;
    idx = note*STACK_MAX + sp;
    zone = stack_data[idx];
    stack_sp[note] = sp;
    zone;
  ) : (
    -1;
  );
);

function peek_zone(note) local(sp, idx) (
  sp = stack_sp[note];
  sp > 0 ? (
    idx = note*STACK_MAX + (sp - 1);
    stack_data[idx];
  ) : -1;
);

function zone_for_note(note) (
  note < slider1 ? 0 :
  note > slider1 ? 1 :
  slider4;
);

function set_chan(statusbyte, ch1to16) (
  (statusbyte & 0xF0) | ((ch1to16-1) & 0x0F);
);

function send_to_zone(offset, statusbyte, msg23, zone) (
  out1 = set_chan(statusbyte, slider2);
  midisend(offset, out1, msg23);
);

function send_other(offset, statusbyte, msg23) (
  mode = slider5;
  mode == 0 ? (
    midisend(offset, statusbyte, msg23);
  ) : (
    // block
  );
);

@slider
// (No heavy work needed here)

@block
while (midirecv(offset, msg1, msg23)) (
  status = msg1 & 0xF0;
  in_ch = msg1 & 0x0F;
  note = msg23 & 0xFF;
  vel = (msg23 >> 8) & 0xFF;
  zone = zone_for_note(note);
  accepted = (zone == 0 && in_ch == slider3 - 1) || (zone == 1 && in_ch == slider4 - 1);
  status == 0x90 ? (
    accepted ? (
      vel > 0 ? (
        push_zone(note, zone);
        send_to_zone(offset, msg1, msg23, zone);
      ) : (
        zone = pop_zone(note);
        zone < 0 ? zone = zone_for_note(note);
        send_to_zone(offset, (msg1 & 0xF0) | (msg1 & 0x0F), (0x00 << 8) | note, zone);
      );
    ) : (
      // not accepted, skip
    );
  ) :
  status == 0x80 ? (
    accepted ? (
      zone = pop_zone(note);
      zone < 0 ? zone = zone_for_note(note);
      send_to_zone(offset, msg1, msg23, zone);
    ) : (
      // skip
    );
  ) :
  status == 0xA0 ? (
    accepted ? (
      zone = peek_zone(note);
      zone < 0 ? zone = zone_for_note(note);
      send_to_zone(offset, msg1, msg23, zone);
    ) : (
      // skip
    );
  ) :
  (
    send_other(offset, msg1, msg23);
  );
);

@gfx 200 80
gfx_setfont(1, "Arial", 16);
gfx_x = 10; gfx_y = 10;
gfx_printf("Split: %d   Out ch: %d   Low in: %d   High in: %d", slider1, slider2, slider3, slider4);

gfx_setfont(1, "Arial", 12);
gfx_x = 10; gfx_y = 55;
mode = slider5;
mode == 0 ? gfx_printf("Other MIDI: PASS") :
gfx_printf("Other MIDI: BLOCK");
