desc:Note State + Grid (16 slots) — toggle on NOTE ON>0, offset & channel selectable — NO MIDI OUT

// -------------------------
// Sliders (state+grid only)
// -------------------------
slider1:0<0,16,1{Omni,Channel 1,Channel 2,Channel 3,Channel 4,Channel 5,Channel 6,Channel 7,Channel 8,Channel 9,Channel 10,Channel 11,Channel 12,Channel 13,Channel 14,Channel 15,Channel 16}>MIDI Channel (for input gating)
slider2:1<1,3,1{Dark Gray,Gray,Black}>Color Scheme
slider3:0<0,112,1>Slot base note (offset) // 0..112 so offset+15 <= 127

// -------------------------
// @init — state & minimal logs
// -------------------------
@init
SLOTS = 16;                       // 4x4 grid
STATE_BASE = 0; STATE_SIZE = SLOTS;
state = STATE_BASE;               // 16 booleans: 0/1

// settings
channel     = slider1 - 1;        // -1=Omni, 0..15
color_mode  = slider2|0;
slot_offset = slider3|0;

// minimal logs for UI
last_in_status=-1; last_in_ch=-1; last_in_d1=-1; last_in_d2=-1;
last_toggle_slot=-1; last_toggle_newstate=-1;
last_reset_cc=-1; last_reset_ch=-1;

// clear states
i=0; loop(STATE_SIZE, state[i]=0; i+=1;);

// -------------------------
// @slider — keep settings in sync
// -------------------------
@slider
channel     = slider1 - 1;        // -1..15
color_mode  = slider2|0;
slot_offset = slider3|0;          // 0..112

// -------------------------
// @block — update ONLY internal state (NO MIDI OUT / NO THRU)
// -------------------------
@block
while ( midirecv(offset, msg1, msg23) ? 
(
  status = msg1 & 0xF0;
  ch     = msg1 & 0x0F;
  d1 =  msg23       & 0x7F;    // note/cc
  d2 = (msg23 >> 8) & 0x7F;    // vel/value

  // minimal IN log for UI
  last_in_status=status; last_in_ch=ch; last_in_d1=d1; last_in_d2=d2;

  reacts = (channel < 0) || (ch == channel);

  // NOTE ON with vel > 0 => toggle slot (state only)
  (status==0x90) && (d2>0) && reacts ? (
    slot = d1 - slot_offset;
    (slot >= 0 && slot < SLOTS) ? (
      newstate = state[slot] ? 0 : 1;
      state[slot] = newstate;
      last_toggle_slot = slot;
      last_toggle_newstate = newstate;
    );
  );

  // All Notes Off(123) / All Sound Off(120) => clear state (no MIDI out)
  (status==0xB0) ? (
    cc = d1;
    (cc == 123 || cc == 120) ? (
      i=0; loop(SLOTS, state[i]=0; i+=1;);
      last_reset_cc = cc; last_reset_ch = ch;
    );
  );

  // swallow everything (no pass-through / no out)
  1;
) : 0 );

// -------------------------
// @gfx — UI + 4x4 grid (state visualisation only)
// -------------------------
@gfx
gfx_clear = color_mode == 1 ? 0x202020 : color_mode == 2 ? 0x303030 : 0x000000;
gfx_a = 1;
margin=10; pad_between=4; bottompad=margin; cols=4; rows=4;
gfx_setfont(1,"",14);

// header
#ch_str=""; (channel<0)?strcpy(#ch_str,"Omni"):sprintf(#ch_str,"Ch %d",channel+1);
sprintf(#hdr,"State+Grid — %s — Slots:16 — Offset:%d..%d", #ch_str, slot_offset, slot_offset+15);
gfx_measurestr(#hdr, w,h); gfx_r=gfx_g=gfx_b=1; gfx_x=margin; gfx_y=margin; gfx_drawstr(#hdr);

// IN log
(last_in_status>=0)?
(
  #it=""; (last_in_status==0x80)?strcpy(#it,"IN: NoteOff")
  : (last_in_status==0x90)?strcpy(#it,"IN: NoteOn")
  : (last_in_status==0xB0)?strcpy(#it,"IN: CC")
  : (last_in_status==0xE0)?strcpy(#it,"IN: Pitch")
  : sprintf(#it,"IN: 0x%02X",last_in_status);
  sprintf(#inln,"%s  Ch %d  d1=%3d  d2=%3d",#it,last_in_ch+1,last_in_d1,last_in_d2);
)
:
(
  strcpy(#inln,"IN: —");
);
gfx_measurestr(#inln, iw, ih); gfx_x=margin; gfx_y=margin+h+pad_between; gfx_drawstr(#inln);

// last toggle / last reset
(last_toggle_slot>=0)?
(
  sprintf(#tgl,"Last toggle: slot %d  -> %s  (note %d)", last_toggle_slot, (last_toggle_newstate?"ON":"OFF"), slot_offset+last_toggle_slot);
)
:
(
  strcpy(#tgl,"Last toggle: —");
);
gfx_measurestr(#tgl, tw, th); gfx_x=margin; gfx_y=margin+h+pad_between+ih+pad_between; gfx_drawstr(#tgl);

(last_reset_cc>=0)?
(
  sprintf(#rst,"Last reset: CC %d  on Ch %d", last_reset_cc, last_reset_ch+1);
)
:
(
  strcpy(#rst,"Last reset: —");
);
gfx_measurestr(#rst, rw, rh); gfx_x=margin; gfx_y=margin+h+pad_between+ih+pad_between+th+pad_between; gfx_drawstr(#rst);

// GRID 4x4 — left-to-right, top-to-bottom
top = margin+h+pad_between+ih+pad_between+th+pad_between+rh+pad_between;
avail_w = max(1, gfx_w-2*margin);
avail_h = max(1, gfx_h-top-bottompad-20-pad_between);
cell_w = floor(avail_w/cols); cell_h = floor(avail_h/rows); cell_h<18?cell_h=18;
grid_w = cell_w*cols; grid_h = cell_h*rows;
grid_x0 = margin + floor((avail_w-grid_w)*0.5);
grid_y0 = top;

i=0; loop(SLOTS,
  row = floor(i/cols);
  col = i % cols;

  gx = grid_x0 + col * cell_w;                  // left to right
  gy = grid_y0 + row * cell_h;                  // top to bottom

  on = state[i]?1:0;
  real_note = slot_offset+i; real_note<0?real_note=0:real_note>127?real_note=127;

  // cell background
  gfx_r=on?0.10:0.07; gfx_g=on?0.30:0.07; gfx_b=on?0.10:0.07; gfx_rect(gx,gy,cell_w-1,cell_h-1);
  // border
  gfx_r=gfx_g=gfx_b=0.6;
  gfx_line(gx,gy,gx+cell_w-1,gy);
  gfx_line(gx,gy,gx,gy+cell_h-1);
  gfx_line(gx+cell_w-1,gy,gx+cell_w-1,gy+cell_h-1);
  gfx_line(gx,gy+cell_h-1,gx+cell_w-1,gy+cell_h-1);

  // label
  gfx_r=on?0.2:0.8; gfx_g=on?1.0:0.8; gfx_b=on?0.2:0.8;
  gfx_x=gx+4; gfx_y=gy+floor((cell_h-12)*0.5);
  sprintf(#lab,"N %03d",real_note); gfx_drawstr(#lab);

  i+=1;
);

gfx_dirty=1;
