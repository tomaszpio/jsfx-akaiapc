desc:Note On Toggler — 2×64 Notes, Omni + Scalable UI (+ optional Note Off toggle)

// -------------------------
// Sliders
// -------------------------
slider1:0<0,16,1{Omni,Channel 1,Channel 2,Channel 3,Channel 4,Channel 5,Channel 6,Channel 7,Channel 8,Channel 9,Channel 10,Channel 11,Channel 12,Channel 13,Channel 14,Channel 15,Channel 16}>MIDI Channel
slider2:1<1,3,1{Dark Gray,Gray,Black}>Color Scheme
slider3:0<0,1,1{Notes 0–63,Notes 64–127}>Page
slider4:0<0,1,1{Off,On}>Toggle on Note Off

// -------------------------
// @init
// -------------------------
@init
NOTES_PER_PAGE = 64;
TOTAL_NOTES = 128;

channel       = slider1 - 1; // -1 = Omni; 0..15 = channels 1..16
color_mode    = slider2;
page          = slider3;
toggle_noteoff= slider4;

last_note = -1;
last_vel  = -1;
last_ch   = -1;
last_cmd  = -1;

// We'll use state[] as our memory array for 128 notes (0..127)
// All init zeros by default in EEL2.

// -------------------------
// @slider
// -------------------------
@slider
channel       = slider1 - 1;
color_mode    = slider2;
page          = slider3;
toggle_noteoff= slider4;

// -------------------------
// Helpers
// -------------------------
function in_range(n, lo, hi) (
  n >= lo && n < hi;
);

function reacts_to_channel(ch) (
  channel < 0 || ch == channel; // Omni or exact match
);

// Toggle handler for a MIDI note number 'note'
function toggle_note_state(note) local(idx) (
  idx = note & 0x7F; // clamp 0..127
  state[idx] = state[idx] ? 0 : 1;
);

// Reset current page or all? Spec says reset on CC 120/123: we clear both pages.
function reset_all_states()
(
  i = 0;
  loop(TOTAL_NOTES,
    state[i] = 0;
    i += 1;
  );
);

// -------------------------
// @block — MIDI logic
// -------------------------
@block
while ( midirecv(offset, msg1, msg23) ?
(
  status = msg1 & 0xF0;
  ch     = msg1 & 0x0F;

  // Decode common fields when needed
  (status == 0x90 || status == 0x80 || status == 0xB0) ? (
    data1 =  msg23       & 0x7F;
    data2 = (msg23 >> 8) & 0x7F;
  );

  // NOTE ON
  status == 0x90 && reacts_to_channel(ch) ? (
    note = data1;
    vel  = data2;

    base = page ? 64 : 0;
    high = base + NOTES_PER_PAGE;

    // only toggle for notes visible on the selected page
    in_range(note, base, high) && vel > 0 ? (
      toggle_note_state(note);
      last_note = note;
      last_vel  = vel;
      last_ch   = ch;  // 0..15
      last_cmd  = -1;
    );
  );

  // OPTIONAL: toggle also on NOTE OFF if enabled
  status == 0x80 && toggle_noteoff && reacts_to_channel(ch) ? (
    note = data1;
    vel  = data2;

    base = page ? 64 : 0;
    high = base + NOTES_PER_PAGE;

    in_range(note, base, high) ? (
      toggle_note_state(note);
      last_note = note;
      last_vel  = vel;
      last_ch   = ch;
      last_cmd  = -1;
    );
  );

  // CONTROL CHANGE — CC120 (All Sound Off) or CC123 (All Notes Off) → reset all
  status == 0xB0 && reacts_to_channel(ch) ? (
    cc  = data1;
    val = data2;

    (cc == 120 || cc == 123) ? (
      reset_all_states();
      last_cmd  = cc;  // display which CC reset us
      last_note = -1;
      last_vel  = -1;
      last_ch   = ch;
    );
  );

  // pass-through
  midisend(offset, msg1, msg23);
  1;
) : 0 );
  
// -------------------------
// @gfx — scalable UI
// -------------------------
@gfx
// Background by color scheme (labels match values now)
gfx_clear = color_mode == 1 ? 0x202020   // Dark Gray
         : color_mode == 2 ? 0x303030   // Gray
         :                    0x000000; // Black
gfx_a = 1;

// Layout parameters
margin    = 10;
header_h  = 24;   // top header line
status_h  = 18;   // status line under header
top_y     = margin + header_h + 4;
bottompad = margin;

cols = 8;
rows = 8;

// Compute cell size from current window size
avail_w = max(1, gfx_w - 2*margin);
avail_h = max(1, gfx_h - (margin + header_h + status_h + bottompad));

cell_w = floor(avail_w / cols);
cell_h = floor(avail_h / rows);
grid_w = cell_w * cols;
grid_h = cell_h * rows;

// Center grid horizontally within margins if there's leftover space
grid_x0 = margin + floor((avail_w - grid_w) * 0.5);
grid_y0 = top_y;

// Header text
gfx_r = gfx_g = gfx_b = 1;
gfx_x = margin;
gfx_y = margin;

(channel < 0) ?
  sprintf(#hdr, "Note Toggler — Channel: Omni — Page: %s", page ? "64–127" : "0–63")
:
  sprintf(#hdr, "Note Toggler — Channel: %d — Page: %s", channel+1, page ? "64–127" : "0–63");

gfx_drawstr(#hdr);

// Status line (last event)
gfx_x = margin;
gfx_y = margin + header_h;

(last_note >= 0) ? (
  // show last note/vel/ch
  sprintf(#st, "Last: Note %d  Vel %d  Ch %d%s",
          last_note, max(0,last_vel), (last_ch>=0?last_ch+1:0),
          toggle_noteoff ? "  [NoteOff toggle: ON]" : "");
) :
(last_cmd >= 0) ? (
  sprintf(#st, "Reset via CC %d  Ch %d", last_cmd, (last_ch>=0?last_ch+1:0));
) : (
  sprintf(#st, "Waiting for MIDI...");
);
gfx_drawstr(#st);

// Grid draw
base = page ? 64 : 0;

i = 0;
loop(NOTES_PER_PAGE,
  row = floor(i / cols);
  col = i % cols;

  x = grid_x0 + col * cell_w;
  y = grid_y0 + row * cell_h;

  // Fill background rectangle lightly depending on state
  idx_note = base + i;
  on = state[idx_note] ? 1 : 0;

  // cell background box (optional subtle fill)
  gfx_r = on ? 0.10 : 0.07;
  gfx_g = on ? 0.30 : 0.07;
  gfx_b = on ? 0.10 : 0.07;
  gfx_rect(x, y, cell_w-1, cell_h-1);

  // Border
  gfx_r = gfx_g = gfx_b = 0.6;
  gfx_line(x, y, x + cell_w - 1, y);
  gfx_line(x, y, x, y + cell_h - 1);
  gfx_line(x + cell_w - 1, y, x + cell_w - 1, y + cell_h - 1);
  gfx_line(x, y + cell_h - 1, x + cell_w - 1, y + cell_h - 1);

  // Text label inside cell
  gfx_r = on ? 0.2 : 0.8;   // slightly brighter text when off
  gfx_g = on ? 1.0 : 0.8;
  gfx_b = on ? 0.2 : 0.8;

  // Center text
  gfx_x = x + 4;
  gfx_y = y + floor((cell_h - 12) * 0.5);

  sprintf(#note_str, "N %03d", idx_note);
  gfx_drawstr(#note_str);

  i += 1;
);

gfx_dirty = 1;
