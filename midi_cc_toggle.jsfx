desc:Note On Toggler - 64 slots (toggle only on NOTE ON > 0), Omni/Channel, slot offset, interval + scalable UI + reset on CC120/123 + logs + Thru toggle

// -------------------------
// Sliders
// -------------------------
slider1:0<0,16,1{Omni,Channel 1,Channel 2,Channel 3,Channel 4,Channel 5,Channel 6,Channel 7,Channel 8,Channel 9,Channel 10,Channel 11,Channel 12,Channel 13,Channel 14,Channel 15,Channel 16}>MIDI Channel
slider2:1<1,3,1{Dark Gray,Gray,Black}>Color Scheme
slider3:0<0,64,1>Slot base note (offset)
slider4:200<50,2000,10>Output interval (ms)
slider5:1<0,1,1{Thru Off,Thru On}>MIDI Thru

// -------------------------
// @init
// -------------------------
@init
SLOTS = 64;                       // 8x8 grid
STATE_BASE = 0; STATE_SIZE = SLOTS;
state = STATE_BASE;               // 64 booleans: 0/1

// settings
channel     = slider1 - 1;        // -1=Omni (OUT on Ch1), 0..15
color_mode  = slider2;
slot_offset = slider3;
thru_on     = slider5|0;

// logs
last_in_status=-1; last_in_ch=-1; last_in_d1=-1; last_in_d2=-1;
last_out_status=-1; last_out_ch=-1; last_out_d1=-1; last_out_d2=-1;
last_toggle_slot=-1; last_toggle_newstate=-1;
last_reset_cc=-1; last_reset_ch=-1;

// clear states
i=0; loop(STATE_SIZE, state[i]=0; i+=1;);

// timer
tick_ms    = slider4|0;
tick_samps = max(1, floor(srate * tick_ms / 1000));
tick_accum = 0;

// -------------------------
// helpers
// -------------------------
function send_all_slots_noteoff(off) local(out_ch,i,note,out_m1,out_m23)(
  out_ch = (channel >= 0) ? channel : 0;
  i=0;
  loop(SLOTS,
    note = slot_offset + i;
    note < 0 ? note = 0 : note > 127 ? note = 127;
    out_m1  = (0x80 | (out_ch & 0x0F));
    out_m23 = (0 << 8) | (note & 0x7F);
    midisend(off, out_m1, out_m23);
    last_out_status=0x80; last_out_ch=out_ch; last_out_d1=note&0x7F; last_out_d2=0;
    i+=1;
  );
);

// -------------------------
// @slider
// -------------------------
@slider
channel     = slider1 - 1;
color_mode  = slider2;
slot_offset = slider3;
thru_on     = slider5|0;

tick_ms = slider4|0; tick_ms<50 ? tick_ms=50 : tick_ms>2000 ? tick_ms=2000;
tick_samps = max(1, floor(srate * tick_ms / 1000));
tick_accum = 0;

// -------------------------
// @block — toggle ONLY on NOTE ON > 0; CC120/123 = reset (no-thru)
// -------------------------
@block
while ( midirecv(offset, msg1, msg23) ?
(
  status = msg1 & 0xF0;
  ch     = msg1 & 0x0F;
  d1 =  msg23       & 0x7F;    // note/cc
  d2 = (msg23 >> 8) & 0x7F;    // vel/value

  // IN log
  last_in_status=status; last_in_ch=ch; last_in_d1=d1; last_in_d2=d2;

  reacts = (channel < 0) || (ch == channel);
  send_thru = thru_on;

  // NOTE ON with vel > 0 => toggle slot
  (status==0x90) && (d2>0) && reacts ? (
    slot = d1 - slot_offset;
    (slot >= 0 && slot < SLOTS) ? (
      newstate = state[slot] ? 0 : 1;
      state[slot] = newstate;
      last_toggle_slot = slot;
      last_toggle_newstate = newstate;
    );
  );

  // All Notes Off / All Sound Off => reset + immediate NoteOff for all slots
  (status==0xB0) ? (
    cc = d1;
    (cc == 123 || cc == 120) ? (
      i=0; loop(SLOTS, state[i]=0; i+=1;);
      last_reset_cc = cc; last_reset_ch = ch;
      send_all_slots_noteoff(offset);
      send_thru = 0; // block the CC itself
    );
  );

  // pass other MIDI through unchanged (depending on Thru slider)
  send_thru ? midisend(offset, msg1, msg23);

  1;
) : 0 );

// -------------------------
// periodic OUT for 64 slots (based solely on grid state)
// -------------------------
tick_accum += samplesblock;
while (tick_accum >= tick_samps) (
  tick_accum -= tick_samps;

  out_ch = (channel >= 0) ? channel : 0; // Omni -> Ch1

  i=0;
  loop(SLOTS,
    note_out = slot_offset + i;
    note_out<0 ? note_out=0 : note_out>127 ? note_out=127;

    is_on = state[i] ? 1 : 0;
    st  = is_on ? 0x90 : 0x80;   // ON -> NoteOn, OFF -> NoteOff
    vel = is_on ? 100  : 0;

    out_m1  = (st | (out_ch & 0x0F));
    out_m23 = ((vel & 0x7F) << 8) | (note_out & 0x7F);
    midisend(0, out_m1, out_m23);

    last_out_status=st; last_out_ch=out_ch; last_out_d1=note_out&0x7F; last_out_d2=vel&0x7F;

    i+=1;
  );
);

// -------------------------
// @gfx — UI + grid + logs
// -------------------------
@gfx
gfx_clear = color_mode == 1 ? 0x202020 : color_mode == 2 ? 0x303030 : 0x000000;
gfx_a = 1;
margin=10; pad_between=4; bottompad=margin; cols=8; rows=8;
gfx_setfont(1,"",14);

// header
#ch_str=""; (channel<0)?strcpy(#ch_str,"Omni(out->Ch1)"):sprintf(#ch_str,"Ch %d",channel+1);
sprintf(#hdr,"Note Toggler - %s - Slots:64 - Offset:%d - Tick:%d ms - Thru:%s",
        #ch_str, slot_offset, tick_ms, (thru_on?"On":"Off"));
gfx_measurestr(#hdr, w,h); gfx_r=gfx_g=gfx_b=1; gfx_x=margin; gfx_y=margin; gfx_drawstr(#hdr);

// IN log
(last_in_status>=0)?
(
  #it=""; (last_in_status==0x80)?strcpy(#it,"IN: NoteOff")
  : (last_in_status==0x90)?strcpy(#it,"IN: NoteOn")
  : (last_in_status==0xB0)?strcpy(#it,"IN: CC")
  : (last_in_status==0xE0)?strcpy(#it,"IN: Pitch")
  : sprintf(#it,"IN: 0x%02X",last_in_status);
  sprintf(#inln,"%s  Ch %d  d1=%3d  d2=%3d",#it,last_in_ch+1,last_in_d1,last_in_d2);
)
:
(
  strcpy(#inln,"IN: —");
);
gfx_measurestr(#inln, iw, ih); gfx_x=margin; gfx_y=margin+h+pad_between; gfx_drawstr(#inln);

// last toggle / last reset
(last_toggle_slot>=0)?
(
  sprintf(#tgl,"Last toggle: slot %d  -> %s  (note %d)", last_toggle_slot, (last_toggle_newstate?"ON":"OFF"), slot_offset+last_toggle_slot);
)
:
(
  strcpy(#tgl,"Last toggle: —");
);
gfx_measurestr(#tgl, tw, th); gfx_x=margin; gfx_y=margin+h+pad_between+ih+pad_between; gfx_drawstr(#tgl);

(last_reset_cc>=0)?
(
  sprintf(#rst,"Last reset: CC %d  on Ch %d", last_reset_cc, last_reset_ch+1);
)
:
(
  strcpy(#rst,"Last reset: —");
);
gfx_measurestr(#rst, rw, rh); gfx_x=margin; gfx_y=margin+h+pad_between+ih+pad_between+th+pad_between; gfx_drawstr(#rst);

// GRID 8x8 — smallest at bottom-left, largest at top-right
top = margin+h+pad_between+ih+pad_between+th+pad_between+rh+pad_between;
avail_w = max(1, gfx_w-2*margin);
avail_h = max(1, gfx_h-top-bottompad-20-pad_between);
cell_w = floor(avail_w/cols); cell_h = floor(avail_h/rows); cell_h<14?cell_h=14;
grid_w = cell_w*cols; grid_h = cell_h*rows;
grid_x0 = margin + floor((avail_w-grid_w)*0.5);
grid_y0 = top;

i=0; loop(SLOTS,
  // logical row from bottom, then flip vertically to compute screen Y
  row_from_bottom = floor(i/cols);
  col = i % cols;
  vrow = (rows - 1) - row_from_bottom;          // flip: 0->bottom, rows-1->top

  gx = grid_x0 + col * cell_w;                  // left to right
  gy = grid_y0 + vrow * cell_h;                 // bottom to top

  on = state[i]?1:0;
  real_note = slot_offset+i; real_note<0?real_note=0:real_note>127?real_note=127;

  // cell background
  gfx_r=on?0.10:0.07; gfx_g=on?0.30:0.07; gfx_b=on?0.10:0.07; gfx_rect(gx,gy,cell_w-1,cell_h-1);
  // border
  gfx_r=gfx_g=gfx_b=0.6;
  gfx_line(gx,gy,gx+cell_w-1,gy);
  gfx_line(gx,gy,gx,gy+cell_h-1);
  gfx_line(gx+cell_w-1,gy,gx+cell_w-1,gy+cell_h-1);
  gfx_line(gx,gy+cell_h-1,gx+cell_w-1,gy+cell_h-1);

  // label
  gfx_r=on?0.2:0.8; gfx_g=on?1.0:0.8; gfx_b=on?0.2:0.8;
  gfx_x=gx+4; gfx_y=gy+floor((cell_h-12)*0.5);
  sprintf(#lab,"N %03d",real_note); gfx_drawstr(#lab);

  i+=1;
);

// OUT log
(last_out_status>=0)?
(
  #ot=""; (last_out_status==0x80)?strcpy(#ot,"OUT: NoteOff")
  : (last_out_status==0x90)?strcpy(#ot,"OUT: NoteOn")
  : (last_out_status==0xB0)?strcpy(#ot,"OUT: CC")
  : (last_out_status==0xE0)?strcpy(#ot,"OUT: Pitch")
  : sprintf(#ot,"OUT: 0x%02X",last_out_status);
  sprintf(#outln,"%s  Ch %d  d1=%3d  d2=%3d  (tick %d ms)",#ot,last_out_ch+1,last_out_d1,last_out_d2,tick_ms);
)
:
(
  strcpy(#outln,"OUT: —");
);
gfx_r=gfx_g=gfx_b=1; gfx_x=margin; gfx_y=grid_y0+grid_h+pad_between; gfx_drawstr(#outln);

gfx_dirty=1;
