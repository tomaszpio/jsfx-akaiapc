desc:Note On Toggler — 2×64 Notes, Omni + Scalable UI (+ optional Note Off toggle)

// -------------------------
// Sliders
// -------------------------
slider1:0<0,16,1{Omni,Channel 1,Channel 2,Channel 3,Channel 4,Channel 5,Channel 6,Channel 7,Channel 8,Channel 9,Channel 10,Channel 11,Channel 12,Channel 13,Channel 14,Channel 15,Channel 16}>MIDI Channel
slider2:1<1,3,1{Dark Gray,Gray,Black}>Color Scheme
slider3:0<0,1,1{Notes 0–63,Notes 64–127}>Page
slider4:0<0,1,1{Off,On}>Toggle on Note Off

// -------------------------
// @init
// -------------------------
@init
NOTES_PER_PAGE = 64;
TOTAL_NOTES = 128;

channel        = slider1 - 1; // -1 = Omni; 0..15 = channels 1..16
color_mode     = slider2;
page           = slider3;
toggle_noteoff = slider4;

last_note = -1;
last_vel  = -1;
last_ch   = -1;
last_cmd  = -1;

// state[]: pamięć stanów 0..127 (domyślnie 0)

// -------------------------
// @slider
// -------------------------
@slider
channel        = slider1 - 1;
color_mode     = slider2;
page           = slider3;
toggle_noteoff = slider4;

// -------------------------
// Helpers
// -------------------------
function in_range(n, lo, hi) (
  n >= lo && n < hi;
);

function reacts_to_channel(ch) (
  channel < 0 || ch == channel; // Omni lub dokładny kanał
);

function toggle_note_state(note) local(idx) (
  idx = note & 0x7F; // 0..127
  state[idx] = state[idx] ? 0 : 1;
);

function reset_all_states()
(
  i = 0;
  loop(TOTAL_NOTES,
    state[i] = 0;
    i += 1;
  );
);

// -------------------------
// @block — MIDI logic
// -------------------------
@block
while ( midirecv(offset, msg1, msg23) ?
(
  status = msg1 & 0xF0;
  ch     = msg1 & 0x0F;

  (status == 0x90 || status == 0x80 || status == 0xB0) ? (
    data1 =  msg23       & 0x7F;
    data2 = (msg23 >> 8) & 0x7F;
  );

  // NOTE ON
  status == 0x90 && reacts_to_channel(ch) ? (
    note = data1;
    vel  = data2;

    base = page ? 64 : 0;
    high = base + NOTES_PER_PAGE;

    in_range(note, base, high) && vel > 0 ? (
      toggle_note_state(note);
      last_note = note;
      last_vel  = vel;
      last_ch   = ch;
      last_cmd  = -1;
    );
  );

  // OPTIONAL: toggle także na NOTE OFF (jeśli włączone)
  status == 0x80 && toggle_noteoff && reacts_to_channel(ch) ? (
    note = data1;
    vel  = data2;

    base = page ? 64 : 0;
    high = base + NOTES_PER_PAGE;

    in_range(note, base, high) ? (
      toggle_note_state(note);
      last_note = note;
      last_vel  = vel;
      last_ch   = ch;
      last_cmd  = -1;
    );
  );

  // CONTROL CHANGE — CC120/CC123 -> reset wszystkich stanów
  status == 0xB0 && reacts_to_channel(ch) ? (
    cc  = data1;
    val = data2;

    (cc == 120 || cc == 123) ? (
      reset_all_states();
      last_cmd  = cc;
      last_note = -1;
      last_vel  = -1;
      last_ch   = ch;
    );
  );

  // pass-through
  midisend(offset, msg1, msg23);
  1;
) : 0 );

// -------------------------
// @gfx — scalable UI z poprawką statusu
// -------------------------
@gfx
// Tło wg schematu (opis==wartość)
gfx_clear = color_mode == 1 ? 0x202020   // Dark Gray
         : color_mode == 2 ? 0x303030   // Gray
         :                    0x000000; // Black
gfx_a = 1;

// Ustawienia layoutu
margin      = 10;
pad_between = 4;   // odstęp między headerem, statusem i gridem
bottompad   = margin;

cols = 8;
rows = 8;

// Teksty nagłówka i statusu
gfx_setfont(1, "", 14);

(channel < 0) ?
  sprintf(#hdr, "Note Toggler — Channel: Omni — Page: %s", page ? "64–127" : "0–63")
:
  sprintf(#hdr, "Note Toggler — Channel: %d — Page: %s", channel+1, page ? "64–127" : "0–63");

(last_note >= 0) ? (
  sprintf(#st, "Last: Note %d  Vel %d  Ch %d%s",
          last_note, max(0,last_vel), (last_ch>=0?last_ch+1:0),
          toggle_noteoff ? "  [NoteOff toggle: ON]" : "");
) :
(last_cmd >= 0) ? (
  sprintf(#st, "Reset via CC %d  Ch %d", last_cmd, (last_ch>=0?last_ch+1:0));
) : (
  sprintf(#st, "Waiting for MIDI...");
);

// Zmierz rozmiary i narysuj header oraz status
gfx_measurestr(#hdr, hdr_w, hdr_h);
gfx_measurestr(#st,  st_w,  st_h);

// Header
gfx_r = gfx_g = gfx_b = 1;
gfx_x = margin;
gfx_y = margin;
gfx_drawstr(#hdr);

// Status POD headerem (nie nachodzi na grid)
gfx_x = margin;
gfx_y = margin + hdr_h + pad_between;
gfx_drawstr(#st);

// Oblicz obszar siatki poniżej statusu
top_of_grid = margin + hdr_h + pad_between + st_h + pad_between;
avail_w = max(1, gfx_w - 2*margin);
avail_h = max(1, gfx_h - top_of_grid - bottompad);

cell_w = floor(avail_w / cols);
cell_h = floor(avail_h / rows);
grid_w = cell_w * cols;
grid_h = cell_h * rows;

grid_x0 = margin + floor((avail_w - grid_w) * 0.5);
grid_y0 = top_of_grid;

// Rysowanie gridu
base = page ? 64 : 0;

i = 0;
loop(NOTES_PER_PAGE,
  row = floor(i / cols);
  col = i % cols;

  x = grid_x0 + col * cell_w;
  y = grid_y0 + row * cell_h;

  idx_note = base + i;
  on = state[idx_note] ? 1 : 0;

  // Delikatne tło komórki
  gfx_r = on ? 0.10 : 0.07;
  gfx_g = on ? 0.30 : 0.07;
  gfx_b = on ? 0.10 : 0.07;
  gfx_rect(x, y, cell_w-1, cell_h-1);

  // Ramka
  gfx_r = gfx_g = gfx_b = 0.6;
  gfx_line(x, y, x + cell_w - 1, y);
  gfx_line(x, y, x, y + cell_h - 1);
  gfx_line(x + cell_w - 1, y, x + cell_w - 1, y + cell_h - 1);
  gfx_line(x, y + cell_h - 1, x + cell_w - 1, y + cell_h - 1);

  // Tekst w komórce
  gfx_r = on ? 0.2 : 0.8;
  gfx_g = on ? 1.0 : 0.8;
  gfx_b = on ? 0.2 : 0.8;

  gfx_x = x + 4;
  gfx_y = y + floor((cell_h - 12) * 0.5);

  sprintf(#note_str, "N %03d", idx_note);
  gfx_drawstr(#note_str);

  i += 1;
);

gfx_dirty = 1;
