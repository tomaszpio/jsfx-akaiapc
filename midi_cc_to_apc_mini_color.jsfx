desc:APC Mini Pad RGB Toggle (Purple / Off) - Banked Control + Color Picker

slider1:0<0,3,1{Bank 1,Bank 2,Bank 3,Bank 4}>Active Pad Bank
slider2:0<0,63,1>Last Triggered Pad (readonly)
slider3:0<0,127,1>Pad Color Index
slider4:0<0,15,1>Input MIDI Channel (0=Ch1 ... 15=Ch16)
slider5:0<-127,127,1>Note Shift (Semitones)

@init
gfx_clear = 1;
sysex_len = 16;

// Initialize 16 pad toggle variables (used per-bank)
pad0=pad1=pad2=pad3=pad4=pad5=pad6=pad7=pad8=pad9=pad10=pad11=pad12=pad13=pad14=pad15=0;

// Define your 144 RGB triplets here (packed R<<16|G<<8|B)
color[0]=0x000000;  color[1]=0x1E1E1E;  color[2]=0x7F7F7F;  color[3]=0xFFFFFF;  color[4]=0xFF4C4C;
color[5]=0xFF0000;  color[6]=0x590000;  color[7]=0x190000;  color[8]=0xFFBD6C;  color[9]=0xFF5400;
color[10]=0x591D00; color[11]=0x271B00; color[12]=0xFFFF4C; color[13]=0xFFFF00; color[14]=0x595900;
color[15]=0x191900; color[16]=0x88FF4C; color[17]=0x54FF00; color[18]=0x1D5900; color[19]=0x142B00;
color[20]=0x4CFF4C; color[21]=0x00FF00; color[22]=0x005900; color[23]=0x001900; color[24]=0x4CFF5E;
color[25]=0x00FF19; color[26]=0x00590D; color[27]=0x001902; color[28]=0x4CFF88; color[29]=0x00FF55;
color[30]=0x00591D; color[31]=0x001F12; color[32]=0x4CFFB7; color[33]=0x00FF99; color[34]=0x005935;
color[35]=0x001912; color[36]=0x4CC3FF; color[37]=0x00A9FF; color[38]=0x004152; color[39]=0x001019;
color[40]=0x4C88FF; color[41]=0x0055FF; color[42]=0x001D59; color[43]=0x000819; color[44]=0x4C4CFF;
color[45]=0x0000FF; color[46]=0x000059; color[47]=0x000019; color[48]=0x874CFF; color[49]=0x5400FF;
color[50]=0x190064; color[51]=0x0F0030; color[52]=0xFF4CFF; color[53]=0xFF00FF; color[54]=0x590059;
color[55]=0x190019; color[56]=0xFF4C87; color[57]=0xFF0054; color[58]=0x59001D; color[59]=0x220013;
color[60]=0xFF1500; color[61]=0x993500; color[62]=0x795100; color[63]=0x436400; color[64]=0x033900;
color[65]=0x005735; color[66]=0x00547F; color[67]=0x0000FF; color[68]=0x00454F; color[69]=0x2500CC;
color[70]=0x7F7F7F; color[71]=0x202020; color[72]=0xFF0000; color[73]=0xBDFF2D; color[74]=0xAFED06;
color[75]=0x64FF09; color[76]=0x108B00; color[77]=0x00FF87; color[78]=0x00A9FF; color[79]=0x002AFF;
color[80]=0x3F00FF; color[81]=0x7A00FF; color[82]=0xB21A7D; color[83]=0x402100; color[84]=0xFF4A00;
color[85]=0x88E106; color[86]=0x72FF15; color[87]=0x00FF00; color[88]=0x3BFF26; color[89]=0x59FF71;
color[90]=0x38FFCC; color[91]=0x5B8AFF; color[92]=0x3151C6; color[93]=0x877FE9; color[94]=0xD31DFF;
color[95]=0xFF005D; color[96]=0xFF7F00; color[97]=0xB9B000; color[98]=0x835D07; color[99]=0x392B00;
color[100]=0x144C10; color[101]=0x1AD000; color[102]=0x0D5038; color[103]=0x15152A; color[104]=0x16205A;
color[105]=0x693C1C; color[106]=0xA8000A; color[107]=0xDE513D; color[108]=0xD86A1C; color[109]=0xFFE126;
color[110]=0x9EE12F; color[111]=0x67B50F; color[112]=0x1E1E30; color[113]=0xDCFF6B; color[114]=0x80FFBD;
color[115]=0x9A99FF; color[116]=0x8E66FF; color[117]=0x404040; color[118]=0x757575; color[119]=0xE0FFFF;
color[120]=0xA00000; color[121]=0x350000; color[122]=0x1AD000; color[123]=0x074200; color[124]=0xB9B000;
color[125]=0x3F3100; color[126]=0xB35F00; color[127]=0x4B1502;


@block
while (midirecv(offset, msg1, msg2, msg3)) (
    status = msg1 & $xF0;
    channel = (msg1 & $x0F) + 1;

    // Only respond to Note On on channel 1 with velocity > 0
    (status == $x90) && (msg3 > 0) && (channel == slider4 + 1) ? (
  
    
        note = msg2 + slider5;
        (note < 0) ? note = 0;
        (note > 127) ? note = 127;
        bank_offset = slider1 * 16;

        // Check if note is in current bank range
        (note >= bank_offset) && (note < bank_offset + 16) ? (
            pad_index = note - bank_offset;
            slider2 = note;

            // Get toggle state
            val = pad_index == 0 ? pad0 :
                  pad_index == 1 ? pad1 :
                  pad_index == 2 ? pad2 :
                  pad_index == 3 ? pad3 :
                  pad_index == 4 ? pad4 :
                  pad_index == 5 ? pad5 :
                  pad_index == 6 ? pad6 :
                  pad_index == 7 ? pad7 :
                  pad_index == 8 ? pad8 :
                  pad_index == 9 ? pad9 :
                  pad_index == 10 ? pad10 :
                  pad_index == 11 ? pad11 :
                  pad_index == 12 ? pad12 :
                  pad_index == 13 ? pad13 :
                  pad_index == 14 ? pad14 :
                  pad_index == 15 ? pad15 : 0;

            new_val = val == 0 ? 1 : 0;

            // Store toggle state
            pad_index == 0 ? pad0 = new_val :
            pad_index == 1 ? pad1 = new_val :
            pad_index == 2 ? pad2 = new_val :
            pad_index == 3 ? pad3 = new_val :
            pad_index == 4 ? pad4 = new_val :
            pad_index == 5 ? pad5 = new_val :
            pad_index == 6 ? pad6 = new_val :
            pad_index == 7 ? pad7 = new_val :
            pad_index == 8 ? pad8 = new_val :
            pad_index == 9 ? pad9 = new_val :
            pad_index == 10 ? pad10 = new_val :
            pad_index == 11 ? pad11 = new_val :
            pad_index == 12 ? pad12 = new_val :
            pad_index == 13 ? pad13 = new_val :
            pad_index == 14 ? pad14 = new_val :
            pad_index == 15 ? pad15 = new_val;

            // Get RGB for current slider3 color index
            rgb = color[slider3];
            R = (rgb & 0xFF0000) >> 16;
            G = (rgb & 0x00FF00) >> 8;
            B = (rgb & 0x0000FF);

            // Convert RGB 0-255 to SysEx 0-127 scale
            sysexR = R * 127 / 255;
            sysexG = G * 127 / 255;
            sysexB = B * 127 / 255;

            // Prepare SysEx message to light pad
            sysex[0] = 0xF0;
            sysex[1] = 0x47;
            sysex[2] = 0x7F;
            sysex[3] = 0x4F;
            sysex[4] = 0x24;
// Number of data bytes MSB and LSB (split 14-bit count)
sysex[5] = 0x00;  // MSB
sysex[6] = 0x08;         // LSB

// For each pad (only 1 here)
sysex[7] = note;  // Start Pad
sysex[8] = note;  // End Pad

            (new_val == 1) ? (
                // Use selected color for ON state
             sysex[9]  = 0;          // Red MSB
             sysex[10] = sysexR;     // Red LSB
             sysex[11] = 0;          // Green MSB
             sysex[12] = sysexG;     // Green LSB
             sysex[13] = 0;          // Blue MSB
             sysex[14] = sysexB;     // Blue LSB
             sysex[15] = 0xF7;
             midisend_buf(offset, sysex, sysex_len);
            ) : (
                // Off state
                sysex[9] = 0;
                sysex[10] = 0;
                sysex[11] = 0;
                sysex[12] = 0;
                sysex[13] = 0;
                sysex[14] = 0;
                sysex[15] = 0xF7;
                midisend_buf(offset, sysex, sysex_len);
            );

        );
    );
);

@gfx
gfx_set(1,1,1);

// Suppose color[slider3] is a 24-bit integer RGB (0xRRGGBB)
col = color[slider3];

// Extract RGB components (0-255)
r = ((col >> 16) & 0xFF) / 255.0;
g = ((col >> 8) & 0xFF) / 255.0;
b = (col & 0xFF) / 255.0;

// Set color with normalized floats
gfx_set(r, g, b);

// Draw filled rectangle 30x30 at (10,50)
gfx_rect(10, 10, 60, 60);

// Reset to white for next gfx calls
gfx_set(1, 1, 1);