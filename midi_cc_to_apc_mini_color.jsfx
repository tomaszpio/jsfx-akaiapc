desc:Note State + Grid (16 slots) — toggle on NOTE ON>0, offset & channel selectable — NO MIDI OUT

// -------------------------
// Sliders (state+grid only)
// -------------------------
slider1:0<0,16,1{Omni,Channel 1,Channel 2,Channel 3,Channel 4,Channel 5,Channel 6,Channel 7,Channel 8,Channel 9,Channel 10,Channel 11,Channel 12,Channel 13,Channel 14,Channel 15,Channel 16}>MIDI Channel (for input gating)
slider2:1<1,3,1{Dark Gray,Gray,Black}>Color Scheme
slider3:0<0,112,1>Slot base note (offset)
slider4:0<0,127,1>Pad Color Index

// -------------------------
// @init — state & minimal logs
// -------------------------
@init
// color palette (0..127 -> 0xRRGGBB)
color[0]=0x000000;  color[1]=0x1E1E1E;  color[2]=0x7F7F7F;  color[3]=0xFFFFFF;  color[4]=0xFF4C4C;
color[5]=0xFF0000;  color[6]=0x590000;  color[7]=0x190000;  color[8]=0xFFBD6C;  color[9]=0xFF5400;
color[10]=0x591D00; color[11]=0x271B00; color[12]=0xFFFF4C; color[13]=0xFFFF00; color[14]=0x595900;
color[15]=0x191900; color[16]=0x88FF4C; color[17]=0x54FF00; color[18]=0x1D5900; color[19]=0x142B00;
color[20]=0x4CFF4C; color[21]=0x00FF00; color[22]=0x005900; color[23]=0x001900; color[24]=0x4CFF5E;
color[25]=0x00FF19; color[26]=0x00590D; color[27]=0x001902; color[28]=0x4CFF88; color[29]=0x00FF55;
color[30]=0x00591D; color[31]=0x001F12; color[32]=0x4CFFB7; color[33]=0x00FF99; color[34]=0x005935;
color[35]=0x001912; color[36]=0x4CC3FF; color[37]=0x00A9FF; color[38]=0x004152; color[39]=0x001019;
color[40]=0x4C88FF; color[41]=0x0055FF; color[42]=0x001D59; color[43]=0x000819; color[44]=0x4C4CFF;
color[45]=0x0000FF; color[46]=0x000059; color[47]=0x000019; color[48]=0x874CFF; color[49]=0x5400FF;
color[50]=0x190064; color[51]=0x0F0030; color[52]=0xFF4CFF; color[53]=0xFF00FF; color[54]=0x590059;
color[55]=0x190019; color[56]=0xFF4C87; color[57]=0xFF0054; color[58]=0x59001D; color[59]=0x220013;
color[60]=0xFF1500; color[61]=0x993500; color[62]=0x795100; color[63]=0x436400; color[64]=0x033900;
color[65]=0x005735; color[66]=0x00547F; color[67]=0x0000FF; color[68]=0x00454F; color[69]=0x2500CC;
color[70]=0x7F7F7F; color[71]=0x202020; color[72]=0xFF0000; color[73]=0xBDFF2D; color[74]=0xAFED06;
color[75]=0x64FF09; color[76]=0x108B00; color[77]=0x00FF87; color[78]=0x00A9FF; color[79]=0x002AFF;
color[80]=0x3F00FF; color[81]=0x7A00FF; color[82]=0xB21A7D; color[83]=0x402100; color[84]=0xFF4A00;
color[85]=0x88E106; color[86]=0x72FF15; color[87]=0x00FF00; color[88]=0x3BFF26; color[89]=0x59FF71;
color[90]=0x38FFCC; color[91]=0x5B8AFF; color[92]=0x3151C6; color[93]=0x877FE9; color[94]=0xD31DFF;
color[95]=0xFF005D; color[96]=0xFF7F00; color[97]=0xB9B000; color[98]=0x835D07; color[99]=0x392B00;
color[100]=0x144C10; color[101]=0x1AD000; color[102]=0x0D5038; color[103]=0x15152A; color[104]=0x16205A;
color[105]=0x693C1C; color[106]=0xA8000A; color[107]=0xDE513D; color[108]=0xD86A1C; color[109]=0xFFE126;
color[110]=0x9EE12F; color[111]=0x67B50F; color[112]=0x1E1E30; color[113]=0xDCFF6B; color[114]=0x80FFBD;
color[115]=0x9A99FF; color[116]=0x8E66FF; color[117]=0x404040; color[118]=0x757575; color[119]=0xE0FFFF;
color[120]=0xA00000; color[121]=0x350000; color[122]=0x1AD000; color[123]=0x074200; color[124]=0xB9B000;
color[125]=0x3F3100; color[126]=0xB35F00; color[127]=0x4B1502;

SLOTS = 16;                       // 4x4 grid
STATE_BASE = 0; STATE_SIZE = SLOTS;
state = STATE_BASE;               // 16 booleans: 0/1
sysex = 16;

// minimal logs for UI
last_in_status=-1; last_in_ch=-1; last_in_d1=-1; last_in_d2=-1;
last_toggle_slot=-1; last_toggle_newstate=-1;
last_reset_cc=-1; last_reset_ch=-1;

// clear states
i = 0;
loop(STATE_SIZE,
  state[i] = 0;
  i += 1;
);

// Helper: SysEx OFF for pad id 0..63
function send_pad_off(off, pid) (
  sysex[0]  = 0xF0; sysex[1]  = 0x47; sysex[2]  = 0x7F; sysex[3]  = 0x4F; sysex[4]  = 0x24;
  sysex[5]  = 0x00; sysex[6]  = 0x08;
  sysex[7]  = pid & 0x7F;      sysex[8]  = pid & 0x7F;
  sysex[9]  = 0;   sysex[10] = 0;   sysex[11] = 0;   sysex[12] = 0;   sysex[13] = 0;   sysex[14] = 0;
  sysex[15] = 0xF7;
  midisend_buf(off, sysex, 16);
);

// Prebuilt SysEx header
sysex[0] = 0xF0;
sysex[1] = 0x47;
sysex[2] = 0x7F;
sysex[3] = 0x4F;
sysex[4] = 0x24;
sysex[5] = 0x00;
sysex[6] = 0x08;

// -------------------------
// @slider — keep settings in sync
// -------------------------
@slider
channel     = slider1 - 1;        // -1..15
color_mode  = slider2 | 0;
slot_offset = slider3 | 0;        // 0..112
color_idx   = slider4 | 0;

// -------------------------
// @block — update ONLY internal state (NO MIDI OUT / NO THRU)
// -------------------------
@block
while (
  midirecv(offset, msg1, msg23) ?
  (
    status = msg1 & 0xF0;
    ch     = msg1 & 0x0F;
    d1     =  msg23       & 0x7F; // note/cc
    d2     = (msg23 >> 8) & 0x7F; // vel/value

    // minimal IN log for UI
    last_in_status = status; last_in_ch = ch; last_in_d1 = d1; last_in_d2 = d2;

    reacts = (channel < 0) || (ch == channel);

    // NOTE ON with vel > 0 => toggle slot (state only)  + RGB SysEx
    (status == 0x90) && (d2 > 0) && reacts ? (
      slot = d1 - slot_offset;
      (slot >= 0 && slot < SLOTS) ? (
        newstate = state[slot] ? 0 : 1;
        state[slot] = newstate;
        last_toggle_slot = slot;
        last_toggle_newstate = newstate;

        // map incoming pad id 0..127 -> 0..63 for RGB SysEx
        pad_in  = d1 & 0x7F;
        pad_rgb = pad_in & 0x3F; // (>=64) wrap to 0..63

        (newstate == 1) ? (
          rgb   = color[color_idx];
          R     = (rgb & 0xFF0000) >> 16;
          G     = (rgb & 0x00FF00) >> 8;
          B     = (rgb & 0x0000FF);
          sysexR = R * 127 / 255;
          sysexG = G * 127 / 255;
          sysexB = B * 127 / 255;

          sysex[7] = pad_rgb;
          sysex[8] = pad_rgb;
          sysex[9]  = 0;         sysex[10] = sysexR;
          sysex[11] = 0;         sysex[12] = sysexG;
          sysex[13] = 0;         sysex[14] = sysexB;
          sysex[15] = 0xF7;

          midisend_buf(offset, sysex, 16);
        ) : (
          sysex[7] = pad_rgb;
          sysex[8] = pad_rgb;
          sysex[9]  = 0; sysex[10] = 0;
          sysex[11] = 0; sysex[12] = 0;
          sysex[13] = 0; sysex[14] = 0;
          sysex[15] = 0xF7;

          midisend_buf(offset, sysex, 16);
        );
      );
    );

    // All Notes Off(123) / All Sound Off(120) => clear state (no MIDI out)
    (status == 0xB0) ? (
      cc = d1;
      (cc == 123 || cc == 120) ? (
        i = 0; loop(SLOTS, state[i] = 0; i += 1;);
        last_reset_cc = cc; last_reset_ch = ch;
        pid = 0; loop(64, send_pad_off(offset, pid); pid += 1;);
      );
    );

    // swallow everything (no pass-through / no out)
    1;
  ) : 0
);

// -------------------------
// @gfx — UI + 4x4 grid (state visualisation only)
// -------------------------
@gfx
gfx_clear = (color_mode == 1) ? 0x202020 : (color_mode == 2) ? 0x303030 : 0x000000;
gfx_a = 1;
margin = 10; pad_between = 4; bottompad = margin; cols = 4; rows = 4;
gfx_setfont(1, "", 14);

// header
#ch_str = "";
(channel < 0) ? strcpy(#ch_str, "Omni") : sprintf(#ch_str, "Ch %d", channel + 1);
sprintf(#hdr, "State+Grid — %s — Slots:16 — Offset:%d..%d", #ch_str, slot_offset, slot_offset + 15);
gfx_measurestr(#hdr, w, h);
gfx_r = gfx_g = gfx_b = 1; gfx_x = margin; gfx_y = margin; gfx_drawstr(#hdr);

// IN log
(last_in_status >= 0) ?
(
  #it = "";
  (last_in_status == 0x80) ? strcpy(#it, "IN: NoteOff")
  : (last_in_status == 0x90) ? strcpy(#it, "IN: NoteOn")
  : (last_in_status == 0xB0) ? strcpy(#it, "IN: CC")
  : (last_in_status == 0xE0) ? strcpy(#it, "IN: Pitch")
  : sprintf(#it, "IN: 0x%02X", last_in_status);
  sprintf(#inln, "%s  Ch %d  d1=%3d  d2=%3d", #it, last_in_ch + 1, last_in_d1, last_in_d2);
)
:
(
  strcpy(#inln, "IN: —");
);
gfx_measurestr(#inln, iw, ih);
gfx_x = margin; gfx_y = margin + h + pad_between; gfx_drawstr(#inln);

// last toggle / last reset
(last_toggle_slot >= 0) ?
(
  sprintf(#tgl, "Last toggle: slot %d  -> %s  (note %d)", last_toggle_slot, (last_toggle_newstate ? "ON" : "OFF"), slot_offset + last_toggle_slot);
)
:
(
  strcpy(#tgl, "Last toggle: —");
);
gfx_measurestr(#tgl, tw, th);
gfx_x = margin; gfx_y = margin + h + pad_between + ih + pad_between; gfx_drawstr(#tgl);

(last_reset_cc >= 0) ?
(
  sprintf(#rst, "Last reset: CC %d  on Ch %d", last_reset_cc, last_reset_ch + 1);
)
:
(
  strcpy(#rst, "Last reset: —");
);
gfx_measurestr(#rst, rw, rh);
gfx_x = margin; gfx_y = margin + h + pad_between + ih + pad_between + th + pad_between; gfx_drawstr(#rst);

// ==== Color preview square to the right of logs ====
col = color[color_idx];
pr  = ((col >> 16) & 255) / 255.0;
pg  = ((col >> 8)  & 255) / 255.0;
pb  = ( col        & 255) / 255.0;
box = 48;
bx  = gfx_w - margin - box;
by  = margin + h + pad_between; // aligned with IN log row
gfx_set(pr, pg, pb); gfx_rect(bx, by, box, box); gfx_set(1,1,1);

// GRID 4x4 — left-to-right, top-to-bottom
top     = margin + h + pad_between + ih + pad_between + th + pad_between + rh + pad_between;
avail_w = max(1, gfx_w - 2 * margin);
avail_h = max(1, gfx_h - top - bottompad - 20 - pad_between);
cell_w  = floor(avail_w / cols);
cell_h  = floor(avail_h / rows);
cell_h < 18 ? cell_h = 18;
grid_w  = cell_w * cols;
grid_h  = cell_h * rows;
grid_x0 = margin + floor((avail_w - grid_w) * 0.5);
grid_y0 = top;

i = 0;
loop(SLOTS,
  row = floor(i / cols);
  col = i % cols;

  gx = grid_x0 + col * cell_w;   // left to right
  gy = grid_y0 + row * cell_h;   // top to bottom

  on = state[i] ? 1 : 0;
  real_note = slot_offset + i;
  real_note < 0 ? real_note = 0 : real_note > 127 ? real_note = 127;

  // cell background
  gfx_r = on ? pr * 0.25 : 0.07;
  gfx_g = on ? pg * 0.25 : 0.07;
  gfx_b = on ? pb * 0.25 : 0.07;
  gfx_rect(gx, gy, cell_w - 1, cell_h - 1);

  // border
  gfx_r = gfx_g = gfx_b = 0.6;
  gfx_line(gx, gy, gx + cell_w - 1, gy);
  gfx_line(gx, gy, gx, gy + cell_h - 1);
  gfx_line(gx + cell_w - 1, gy, gx + cell_w - 1, gy + cell_h - 1);
  gfx_line(gx, gy + cell_h - 1, gx + cell_w - 1, gy + cell_h - 1);

  // label
  gfx_r = on ? 0.2 : 0.8;
  gfx_g = on ? 1.0 : 0.8;
  gfx_b = on ? 0.2 : 0.8;
  gfx_x = gx + 4;
  gfx_y = gy + floor((cell_h - 12) * 0.5);
  sprintf(#lab, "N %03d", real_note);
  gfx_drawstr(#lab);

  i += 1;
);

gfx_dirty = 1;
